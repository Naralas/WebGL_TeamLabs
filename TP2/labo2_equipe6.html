<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="./css/stylesheet.css">
    <script src="./js/commonFunctions.js"></script>
    <script src="./js/gl-matrix-min.js"></script>
    <script src="./js/webglTools.js"></script>
		<script src="js/OBJ_loader.js"></script>

    <script src="./SolidShape.js"></script>
    <script src="./Cube.js"></script>
    <script src="./Tetrahedron.js"></script>
    <script src="./Sphere.js"></script>
    <script src="./ImportedModel.js"></script>

    <!-- Vertex Shader -->
    <script id="shader-vs" type="x-shader/x-vertex">
      #define NB_LIGHTS 4

      // vertex's attributes
      attribute vec3 aVertexPosition;
      attribute vec3 aVertexNormal;
      attribute vec4 aColor;

      // uniform variables
      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      uniform mat4 uNormalMatrix;
      uniform vec3 uViewPos;

      // varying variables
      varying vec4 vColor;   // vertex's color
      varying vec3 vNormal;  // vertex's normal
      varying vec3 vFragPos; // vertex's position
      varying vec3 vViewPos; // camera position


    	void main(void) {
        gl_PointSize = 15.0; // to display the lights
        vColor = aColor;
        vViewPos = uViewPos;
        vFragPos = aVertexPosition;

        // compute vertex's normal
        if (aVertexNormal != vec3(0.0,0.0,0.0)) {
          vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));
        } else {
          vNormal = vec3(0.0, 0.0, 0.0);
        }

        // compute vertex's position in camera coordinates system
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  	  }
    </script>

    <!-- Fragment Shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
      #ifdef GL_ES
    		precision highp float;
      #endif
      #define NB_LIGHTS 4

      // adapted from https://learnopengl.com/

      varying vec3 vNormal;  // vertex's normal
      varying vec4 vColor;   // vertex's color
      varying vec3 vFragPos; // vertex's position (world coordinates)
      varying vec3 vViewPos; // camera's position (world coordinates)

      uniform int uLightToggled[NB_LIGHTS];    // each light's position
      uniform vec3 uLightPositions[NB_LIGHTS]; // each light's state

      // lights constants parameters
      float materialShininess = 32.0;
      float lightConstant = 1.0;   // used to compute light's attenuation
      float lightLinear = 0.09;    // used to compute light's attenuation
      float lightQuadratic = 0.01; // used to compute light's attenuation
      vec3 lightAmbient = vec3(0.05, 0.05, 0.05);
      vec3 lightDifuse = vec3(0.8, 0.8, 0.8);
      vec3 lightSpecular = vec3(1.0, 1.0, 1.0);

      /*
      * Computes the final color of a fragment according to a specific point light.
      */
      vec3 calcPointLight(vec3 lightPos, vec3 normal, vec3 fragPos, vec3 viewDir, vec4 defaultColor) {
        vec3 lightDir = normalize(lightPos - fragPos); // light's direction

        // diffuse shading
        float diff = max(dot(normal, lightDir), 0.0);

        // specular shading
        vec3 reflectDir = reflect(-lightDir, normal);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), materialShininess);

        // attenuation
        float distance    = length(lightPos - fragPos);
        float attenuation = 1.0 / (lightConstant + lightLinear * distance + lightQuadratic * (distance * distance));

        // combine results
        vec3 ambient  = lightAmbient * defaultColor.rgb;
        vec3 diffuse  = lightDifuse * diff * defaultColor.rgb;
        vec3 specular = lightSpecular * spec * defaultColor.rgb;

        // apply attenuation
        ambient  *= attenuation;
        diffuse  *= attenuation;
        specular *= attenuation;

        // return combined light's effects
        return (ambient + diffuse + specular);
      }

      void main(void) {
        vec4 defaultColor = vec4(vColor.rgb, 1.0);

        vec3 norm = normalize(vNormal);
        vec3 viewDir = normalize(vViewPos - vFragPos);
        vec3 result = vec3(0.0, 0.0, 0.0);

        // if this isn't part of the curve
        if(vNormal != vec3(0.0, 0.0, 0.0)) {
          // compute the sub-color value for each enabled light
          for(int i=0; i<NB_LIGHTS; i++) {
            if (uLightToggled[i] == 1) {
              //vec3 lightPos = vec3(0.0, 1.0, 0.0);
              vec3 lightPos = uLightPositions[i];
              result += calcPointLight(lightPos, norm, vFragPos, viewDir, defaultColor);
            }
          }

          gl_FragColor = vec4(result, 1.0);
        } else {
          gl_FragColor = defaultColor;
        }
      }
    </script>

    <script>
      // buffers
      var vertexBuffer = null;
      var indexBuffer = null;
      var colorBuffer = null;
      var normalBuffer = null;

      // scene geometry
      var indices = [];
      var vertices = [];
      var colors = [];
      var normals = [];

      // camera
      var mvMatrix = mat4.create();
      var pMatrix = mat4.create();
      var cameraPos = [4.0, -2.5, -6.0];

      // scene
      var solidShapes = [];
      var path = [];
      var drawPath = true;
      var lastTime = performance.now();
      const maxNumberOfSolidShapes = 100;
      var nbImportedModels = 0;
      const maxNumberImportedModels = 15;
      var frameCount = 0;
      var elapsedTime = 0;

      // render
      const fieldOfView = degToRad(45);
      const zNear = 0.1;
      const zFar = 100.0;
      var aspect;

      // lights
      var lightsVerticesOffset = 0;
      var lightsColorsOffset = 0;
      const lightColorOn = {r: 1.0, g: 1.0, b: 0.0, a: 1.0};
      const lightColorOff = {r: 0.0, g: 0.0, b: 0.0, a: 1.0};

      const lightEmitColorOn = {r: 0.1, g: 0.1, b: 0.1};
      const lightEmitColorOff = {r: 0.0, g: 0.0, b: 0.0};

      var lightPositions = [];
      var lightToggled = [];

      const minLightHeight = 0.3;
      const maxLightHeight = 3.5;

      // cooldown to add objects
      var currCooldownAddObject = 0;
      const cooldownAddObject = 500;

      // models
      var importedModels = [];

      /**
      * Creates the "bridges" between JS and the GLSL program (shaders) "prg".
      */
      function initShaderParameters(prg) {
        prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
        prg.vertexNormalAttribute   = glContext.getAttribLocation(prg, "aVertexNormal");
        prg.colorAttribute          = glContext.getAttribLocation(prg, "aColor");

        glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
        glContext.enableVertexAttribArray(prg.vertexNormalAttribute);
        glContext.enableVertexAttribArray(prg.colorAttribute);

        prg.pMatrixUniform        = glContext.getUniformLocation(prg, "uPMatrix");
        prg.mvMatrixUniform       = glContext.getUniformLocation(prg, "uMVMatrix");
        prg.nUniform              = glContext.getUniformLocation(prg, "uNormalMatrix");
        prg.lightPositionsUniform = glContext.getUniformLocation(prg, "uLightPositions");
        prg.lightToggledUniform   = glContext.getUniformLocation(prg, "uLightToggled");
        prg.viewPosUniform        = glContext.getUniformLocation(prg, "uViewPos");
      }

      /**
      * Buffers initialization to send vertices and index data to the shaders.
      */
      function initBuffers() {
        vertexBuffer  = getVertexBufferWithVertices(vertices);
        normalBuffer  = getVertexBufferWithVertices(normals);
        colorBuffer   = getVertexBufferWithVertices(colors);
        indexBuffer   = getIndexBufferWithIndices(indices);
      }

      /**
      * Draws and initializes the scene.
      */
      function drawScene() {
        // for each solid shape, rotate and move it as long as its on the path
        for (let i=solidShapes.length-1; i>=0; i--) {
          if (vec3.distance(vec3.fromValues(solidShapes[i].center.x, solidShapes[i].center.y, solidShapes[i].center.z), vec3.fromValues(0,0,0)) > 7)
            removeElement(solidShapes[i], i);

          if (!ImportedModel.prototype.isPrototypeOf(solidShapes[i])) // desable rotations for imported models to avoid perfomance loss
            rotateElement(solidShapes[i], 0.3, true, true, true, false); // rotate 1 degree on each axis
          moveAlongPath(solidShapes[i], performance.now() - lastTime, i); // move elements along the Bézier curve
        }

        // update buffers
        if (solidShapes.length > 0) {
          vertexBuffer  = getVertexBufferWithVertices(vertices);
          normalBuffer  = getVertexBufferWithVertices(normals);
        }

        // draw fps
        drawFps();

        // draw cooldown
        if (currCooldownAddObject > 0) {
          currCooldownAddObject -= performance.now() - lastTime;
          handleBtnCooldown();
        }

        lastTime = performance.now();

        // init scene
        glContext.clearColor(0.0, 0.0, 0.0, 1.0);
        glContext.enable(glContext.DEPTH_TEST);
        glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
        glContext.viewport(0, 0, c_width, c_height);

        mat4.identity(pMatrix);
        mat4.identity(mvMatrix);

        // sets camera position / orientation
        mat4.rotate(mvMatrix, mvMatrix, degToRad(15), [1.0, 0.0, 0.0]);
        mat4.rotate(mvMatrix, mvMatrix, degToRad(35), [0.0, 1.0, 0.0]);
        mat4.translate(mvMatrix, mvMatrix, cameraPos);

        // sets the perspective
        mat4.perspective(pMatrix, fieldOfView, aspect, zNear, zFar);

        // send the camera matrices
        glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
        glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);

        // send the lights position
        glContext.uniform3fv(prg.lightPositionsUniform, lightPositions);

        // send the lights state
        glContext.uniform1iv(prg.lightToggledUniform, lightToggled);

        // send the camera's position
        glContext.uniform3f(prg.viewPosUniform, cameraPos[0], cameraPos[1], cameraPos[2]);

        // normal matrix
        let normalMatrix = mat4.create();
        mat4.invert(normalMatrix, mvMatrix);
        normalMatrix = mat4.transpose(normalMatrix, normalMatrix);
        glContext.uniformMatrix4fv(prg.nUniform, false, normalMatrix);

        // buffers
        glContext.bindBuffer(glContext.ARRAY_BUFFER, normalBuffer);
        glContext.vertexAttribPointer(prg.vertexNormalAttribute, 3, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
        glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, colorBuffer);
        glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);

        // draw elements
        let numberLightsPoints = 4;
        if (drawPath) {
          glContext.drawElements(glContext.LINE_STRIP, path.length, glContext.UNSIGNED_SHORT, 0); // draw path
          glContext.drawElements(glContext.POINTS, numberLightsPoints, glContext.UNSIGNED_SHORT, path.length * 2); // draw lights
          glContext.drawElements(glContext.TRIANGLES, indices.length-path.length-numberLightsPoints, glContext.UNSIGNED_SHORT, (path.length) * 2 + numberLightsPoints * 2); // draw scene
        } else {
          glContext.drawElements(glContext.POINTS, numberLightsPoints, glContext.UNSIGNED_SHORT, 0); // draw lights
          glContext.drawElements(glContext.TRIANGLES, indices.length-numberLightsPoints, glContext.UNSIGNED_SHORT, numberLightsPoints * 2); // draw scene
        }
      }

      /**
      * Initializes the webgl program.
      */
      function initWebGL() {
        glContext = getGLContext("webgl-canvas");
        aspect = glContext.canvas.clientWidth / glContext.canvas.clientHeight;
        initProgram();

        // intialize scene ahd DOM
        initPath(35); // Initializes the path
        initStaticScene(); // Initializes the static scene
        initLightsSliders();
        displayAvailableComplexObjects();
        displayAvailableSimpleObjects();

        // load external models
        loadModel("models/sphere.obj");

        // start webgl application
        initBuffers();
        renderLoop();
      }

      /**
      * Handles button add complex object cooldown.
      */
      function handleBtnCooldown() {
        if (currCooldownAddObject > 0) {
          document.getElementById("btnAddSphere").disabled = true;
          let s = Math.round((currCooldownAddObject / 1000) * 100) / 100;
          document.getElementById("btnAddSphereInfo").innerHTML = "(" + s + " s)";
        } else {
          document.getElementById("btnAddSphere").disabled = false;
          document.getElementById("btnAddSphereInfo").innerHTML = "";
          displayAvailableComplexObjects();
        }
      }

      /**
      * Displays available number of complex objects to add to the scene.
      */
      function displayAvailableComplexObjects() {
        document.getElementById("btnAddSphereInfo").innerHTML = "(" + (maxNumberImportedModels-nbImportedModels) + " disponibles)";
        document.getElementById("btnAddSphere").disabled = maxNumberImportedModels-nbImportedModels <= 0 && maxNumberOfSolidShapes-solidShapes.length;
      }

      /**
      * Display available solid shapes to add to the scene.
      */
      function displayAvailableSimpleObjects() {
        document.getElementById("btnAddCubeInfo").innerHTML = "(" + (maxNumberOfSolidShapes-solidShapes.length) + " disponibles)";
        document.getElementById("btnAddTetrahedronInfo").innerHTML = "(" + (maxNumberOfSolidShapes-solidShapes.length) + " disponibles)";
        document.getElementById("btnAddCube").disabled = maxNumberOfSolidShapes-solidShapes.length <= 0;
        document.getElementById("btnAddTetrahedron").disabled = maxNumberOfSolidShapes-solidShapes.length <= 0;
        document.getElementById("btnAddSphere").disabled = maxNumberImportedModels-nbImportedModels <= 0 && maxNumberOfSolidShapes-solidShapes.length <= 0;
      }

      /**
      * Computes and draws FPS.
      */
      function drawFps() {
        frameCount++;
        elapsedTime += (performance.now() - lastTime);
        if(elapsedTime >= 1000) {
          fps = frameCount;
          frameCount = 0;
          elapsedTime -= 1000;

          document.getElementById("fps").innerHTML = fps + " fps";
        }
      }

      /**
      * Adds a new cube to the scene on the path's origin.
      */
      function addCube(width=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes) {
          solidShapes.push(new Cube(vertices, indices, colors, normals,
                                     width, {x: path[0][0], y: path[0][1], z: path[0][2]}, color
                                   ));
          displayAvailableSimpleObjects();
          initBuffers();
        } else
         console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Adds a new tetrahedron to the scene on the path's origin.
      */
      function addTetrahedron(width=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes) {
          solidShapes.push(new Tetrahedron(vertices, indices, colors, normals,
                                            width, {x: path[0][0], y: path[0][1], z: path[0][2]}, color
                                          ));
          displayAvailableSimpleObjects();
          initBuffers();
         } else
          console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Adds a new sphere to the scene on the path's origin.
      */
      function addSphere(width=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes) {
          if (nbImportedModels < maxNumberImportedModels) {
            nbImportedModels++;
            displayAvailableComplexObjects();
            addImportedModel(importedModels[0].finalVertices, importedModels[0].finalNormals, 0.2, {r:0.0, g:1.0, b:1.0, a:1.0});
          } else
            console.log("You can add at most " + maxNumberImportedModels + " complicated models to the scene.");
        } else
          console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Adds a new imported model to the scene on the path's origin.
      */
      function addImportedModel(presetVertices, presetNormals, ratioSize=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes && currCooldownAddObject <= 0) {
          solidShapes.push(new ImportedModel(vertices, indices, colors, normals, presetVertices, presetNormals,
                                        ratioSize, {x: path[0][0], y: path[0][1], z: path[0][2]}, color
                                      ));
          currCooldownAddObject = cooldownAddObject;
          displayAvailableSimpleObjects();
          initBuffers();
         } else
          console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Moves the given solid shape to a new center.
      */
      function moveElement(solidShape, newCenter, updateBuffers=true) {
        solidShape.move(newCenter);
        if (updateBuffers)
          vertexBuffer = getVertexBufferWithVertices(vertices);
      }

      /**
      * Rotates the given solid shape of a given angle around the specified axis.
      */
      function rotateElement(solidShape, angle, xAxis=true, yAxis=true, zAxis=true, updateBuffers=true) {
        solidShape.rotate(angle, xAxis, yAxis, zAxis);
        if (updateBuffers) {
          vertexBuffer  = getVertexBufferWithVertices(vertices);
          normalBuffer  = getVertexBufferWithVertices(normals);
        }
      }

      /**
      * Removes the given solid shape (at given index in the solidShapes array) from the scene
      * and the solidShapes array. Updates the offsets of each remaining solid shape.
      */
      function removeElement(solidShape, index) {
        if (ImportedModel.prototype.isPrototypeOf(solidShape)) {
          nbImportedModels--;
          displayAvailableComplexObjects();
        }
        solidShape.delete(); // removes the shape's values from the shared arrays (vertices, indices, colors)
        for (let i=index+1; i<solidShapes.length; i++) // updates each remaining solid shape's offsets in shared arrays
        solidShapes[i].updateOffsets(solidShapes[index].numberVertices*3,
        solidShapes[index].numberIndices,
        solidShapes[index].numberVertices*4);
        solidShapes.splice(index, 1); // remove the solid shape from the solidShapes array
        displayAvailableSimpleObjects();
        initBuffers();
      }

      /**
      * Moves the given solid along the path.
      */
      function moveAlongPath(solidShape, dt, index) {
        let delta = solidShape.speed * dt / 1000; // computes the step for this iteration

        let dir = vec3.create();

        // retrieves the current position and creates the direction vector (destination - current pos)
        let currPos = vec3.fromValues(solidShape.center.x, solidShape.center.y, solidShape.center.z);
        vec3.sub(dir, path[solidShape.lastPathPoint+1], currPos);
        vec3.normalize(dir, dir); // normalize the direction
        vec3.scale(dir, dir, delta); // multiply the direction vector by the step

        let newPos = vec3.create();
        vec3.add(newPos, currPos, dir); // new position is the old one added to the movement vector

        // moves the solid shape to its new position
        moveElement(solidShape, {x: newPos[0], y: newPos[1], z: newPos[2]}, false);

        // if the distance between the current position and our goal is smaller than an error
        if (vec3.distance(currPos, path[solidShape.lastPathPoint+1]) < solidShape.positionComparaisonError) {
          solidShape.lastPathPoint++; // increment the path's control point id

          // move the solid shape to the path's control point (to avoid accumulating errors)
          moveElement(solidShape, {x: path[solidShape.lastPathPoint][0], y: path[solidShape.lastPathPoint][1], z: path[solidShape.lastPathPoint][2]});

          // if the last path's control point has been reached
          if (solidShape.lastPathPoint >= path.length-1)
            removeElement(solidShape, index); // remove the solid shape
        }
      }

      /**
      * Changes the given light's position.
      */
      function changeLightPos(lightNumber, newPos) {
        vertices[lightsVerticesOffset + lightNumber * 3 + 1] = parseFloat(newPos);
        vertexBuffer = getVertexBufferWithVertices(vertices);

        lightPositions[lightNumber * 3 + 1] = parseFloat(newPos);
      }

      /**
      * Toggles on and off the given light's id.
      */
      function toggleLight(lightNumber) {
        let offset = lightsColorsOffset + (lightNumber * 4);

        // change light's color
        colors[offset + 0] = lightToggled[lightNumber] == 1 ? lightColorOff.r : lightColorOn.r;
        colors[offset + 1] = lightToggled[lightNumber] == 1 ? lightColorOff.g : lightColorOn.g;
        colors[offset + 2] = lightToggled[lightNumber] == 1 ? lightColorOff.b : lightColorOn.b;
        colors[offset + 3] = lightToggled[lightNumber] == 1 ? lightColorOff.a : lightColorOn.a;
        colorBuffer = getVertexBufferWithVertices(colors);

        // toggle light's state
        lightToggled[lightNumber] = lightToggled[lightNumber] == 0 ? 1 : 0;

        // toggle light's html representation
        document.getElementById("light" + (lightNumber+1) + "Representation").style.backgroundColor = lightToggled[lightNumber] == 1 ? "yellow" : "black";
      }

      /**
      * Toggles on and off the each scene's light.
      */
      function toggleAllLights() {
        for (let i=0; i<4; i++) {
          toggleLight(i);
          document.getElementById("toggleLight" + (i+1)).checked = lightToggled[i] == 1;
        }
      }

      /**
      * Resets each scene's light position.
      */
      function resetLightsPosition() {
        for (let i=0; i<4; i++) {
          changeLightPos(i, minLightHeight);
          document.getElementById("light" + (i+1) + "Position").value = minLightHeight;
        }
      }

      /**
      * Initializes the static objects on the scene.
      */
      function initStaticScene() {
        let groundCenter = {x: 0.0, y: 0.0, z: 0.0};
        let groundSize = {width: 5.5, depth: 5.5};

        initSceneLights();

        let indicesOffset = indices.length;
        // ground
        vertices.push(groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2, // P0
                      groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P1
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P2
                      groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2, // P0
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P2
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2  // P3
                    );
        indices.push(indicesOffset+0, indicesOffset+1, indicesOffset+2,
                     indicesOffset+3, indicesOffset+4, indicesOffset+5);
        colors.push(0.6, 0.6, 0.6, 1.0, // P0
                    0.6, 0.6, 0.6, 1.0, // P1
                    0.6, 0.6, 0.6, 1.0, // P2
                    0.6, 0.6, 0.6, 1.0, // P3
                    0.6, 0.6, 0.6, 1.0, // P4
                    0.6, 0.6, 0.6, 1.0  // P5
                  );
        normals.push(0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0);

        // walls
        // let wallHeight = 5.0;
        // vertices.push(groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2,
        //               groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2,
        //               groundCenter.x + groundSize.width/2, groundCenter.y + wallHeight, groundCenter.z + groundSize.depth/2,
        //               groundCenter.x + groundSize.width/2, groundCenter.y + wallHeight, groundCenter.z - groundSize.depth/2,
        //               groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2,
        //               groundCenter.x - groundSize.width/2, groundCenter.y + wallHeight, groundCenter.z - groundSize.depth/2);
        // indices.push(indicesOffset+4, indicesOffset+5, indicesOffset+6,
        //              indicesOffset+4, indicesOffset+6, indicesOffset+7,
        //              indicesOffset+8, indicesOffset+4, indicesOffset+7,
        //              indicesOffset+8, indicesOffset+7, indicesOffset+9);
        // colors.push(0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0);
        // normals.push(0.0, 0.0, 0.0, 0.0,
        //              0.0, 0.0, 0.0, 0.0,
        //              0.0, 0.0, 0.0, 0.0,
        //              0.0, 0.0, 0.0, 0.0);
      }

      /**
      * Initializes the static lights objects on the scene.
      */
      function initSceneLights() {
        let lightRectangleCenter = {x: 0.0, y: 0.0, z: 0.0};
        let lightRectangleSize = {width: 5.0, depth: 5.0};

        lightsVerticesOffset = vertices.length;
        lightsColorsOffset = colors.length;
        let indicesOffset = indices.length;
        vertices.push(lightRectangleCenter.x - lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z + lightRectangleSize.depth/2, // P0
                      lightRectangleCenter.x - lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z - lightRectangleSize.depth/2, // P1
                      lightRectangleCenter.x + lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z - lightRectangleSize.depth/2, // P2
                      lightRectangleCenter.x + lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z + lightRectangleSize.depth/2  // P3
                    );
        lightPositions.push(lightRectangleCenter.x - lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z + lightRectangleSize.depth/2, // P0
                            lightRectangleCenter.x - lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z - lightRectangleSize.depth/2, // P1
                            lightRectangleCenter.x + lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z - lightRectangleSize.depth/2, // P2
                            lightRectangleCenter.x + lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z + lightRectangleSize.depth/2  // P3
                          );
        lightToggled.push(1,1,1,1);


        indices.push(indicesOffset+0, indicesOffset+1, indicesOffset+2, indicesOffset+3);
        colors.push(lightColorOn.r, lightColorOn.g, lightColorOn.b, lightColorOn.a,  // P0
                    lightColorOn.r, lightColorOn.g, lightColorOn.b, lightColorOn.a,  // P1
                    lightColorOn.r, lightColorOn.g, lightColorOn.b, lightColorOn.a,  // P2
                    lightColorOn.r, lightColorOn.g, lightColorOn.b, lightColorOn.a,  // P3
                  );
        normals.push(0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0
                   );

        toggleLight(0);toggleLight(0);
        toggleLight(1);
        toggleLight(2);
        toggleLight(3);
      }

      /**
      * Initializes the path (Bézier curve) which will be followed by the solid shapes.
      */
      function initPath(numberIterations) {
        // set control points (first is origin and last is goal)
        let controlPoints = [vec3.fromValues( 4.9, 0.1, -4.9),
                             vec3.fromValues( 0.0, 0.2, -4.9),
                             vec3.fromValues(-4.9, 0.5, -4.9),
                             vec3.fromValues(-4.9, 1.4,  0.0),
                             vec3.fromValues(-4.9, 1.5,  6.9),
                             vec3.fromValues( 0.0, 1.6,  4.9),
                             vec3.fromValues( 4.9, 1.7,  4.9),
                             vec3.fromValues( 4.9, 1.7,  0.0),
                             vec3.fromValues( 4.9, 2.1, -4.9),
                             vec3.fromValues( 0.0, 2.3, -4.9),
                             vec3.fromValues(-4.9, 2.5, -4.9),
                             vec3.fromValues(-2.9, 2.7,  0.0),
                             vec3.fromValues(-2.9, 3.4,  1.5)] ;

        const inc = 1/numberIterations; // sets the delta for the Bézier curve

        for (let t=0; t<1; t+=inc) // computes cuve points
          castelJau(t, controlPoints, controlPoints.length);
        path.reverse();

        // adds points to webgl arrays
        if (drawPath) {
          for (let i=0; i<path.length; i++) {
            vertices.push(path[i][0], path[i][1], path[i][2]);
            indices.push(i);
            colors.push(1.0, 0.0, 0.5, 0.2);
            normals.push(0.0, 0.0, 0.0);
          }
        }
      }

      /**
      * Castlejau implementation adapted from : http://fvirtman.free.fr/recueil/02_03_09_bezier.c.php
      * Used to create a Bézier curve with given control points.
      */
      function castelJau(t, controlPoints, nbPoints) {
        let subtab = [];
        if (nbPoints == 1) {
          path.push(controlPoints[0]);
          return;
        }
        for (let i=0; i<nbPoints-1; i++)
          subtab.push(vec3.fromValues(t * controlPoints[i][0] + (1-t) * controlPoints[i+1][0],
                                      t * controlPoints[i][1] + (1-t) * controlPoints[i+1][1],
                                      t * controlPoints[i][2] + (1-t) * controlPoints[i+1][2]));
        castelJau(t, subtab, nbPoints-1);
      }

      /**
      * Initializes lights slides min, max and value.
      */
      function initLightsSliders() {
        for (let i=0; i<4; i++) {
          document.getElementById("light" + (i+1) + "Position").min = minLightHeight.toString();
          document.getElementById("light" + (i+1) + "Position").max = maxLightHeight.toString();
          document.getElementById("light" + (i+1) + "Position").value = lightPositions[(i*3)+1].toString();
        }
      }

      /**
      * Creates an object from the loaded wavefrom model.
      * Adapted code from book "WebGL par la pratique".
      */
      function handleOBJModel(filename, data){
        let objData = new OBJ.Mesh(data);

        let finalVertices = [];
        let finalNormals = [];

        // convert imported object geometry to our format
        for (let i=0; i<objData.indices.length; i++) {
          finalVertices.push(parseFloat(objData.vertices[objData.indices[i]*3 + 0]),
                             parseFloat(objData.vertices[objData.indices[i]*3 + 1]),
                             parseFloat(objData.vertices[objData.indices[i]*3 + 2]));
          finalNormals.push(parseFloat(objData.vertexNormals[objData.indices[i]*3 + 0]),
                            parseFloat(objData.vertexNormals[objData.indices[i]*3 + 1]),
                            parseFloat(objData.vertexNormals[objData.indices[i]*3 + 2]));
        }

        if (finalVertices.length > 0 && finalNormals.length > 0)
          importedModels.push({name: "sphere", finalVertices: finalVertices, finalNormals: finalNormals});
        document.getElementById("btnAddSphere").disabled = importedModels.length <= 0;
      }

      /**
      * Loads given model from filename.
      * Code from book "WebGL par la pratique".
      */
      function loadModel(filename) {
        let request = new XMLHttpRequest();
        request.open("GET", filename);
        request.onreadystatechange = function() {
          if (request.readyState == 4) {
            if(request.status == 404)
              console.info(filename + ' does not exist');
            else {
              let re = /(?:\.([^./]+))?$/;
              let ext = re.exec(filename)[1];
              if (ext == "obj")
                handleOBJModel(filename, request.responseText);
              else
                console.info("unknown format extension: " + ext );
            }
          }
        }
        request.send();
      }

    </script>

    <style>
      .light-div{
        padding: 5px;
        border: 1px solid #CCC;
        border-radius: 4px;
        vertical-align: middle;
        margin-bottom: 10px;
        width: 350px;
      }

      .title{
        line-height: 25px;
        font-weight: bold;
      }

      .label{
        line-height: 25px;
        margin-left: 25px;
      }

      .lightRepresentation-div {
        width: 20px;
        height: 20px;
        display: inline-block;
        float: left;
        border-radius: 2px;
        border: 1px solid lightgray;
      }

      .lightRepresentation-div:hover {
        cursor: pointer;
      }
    </style>

  </head>
  <body onload="initWebGL()">
    <header>
        <h1>&nbsp;Infographie, Labo 2 - Éclairage d'objets 3D animés sur une courbe<br></h1>
        <br>&nbsp;&nbsp;Équipe 6 : Chacun Guillaume, Graells Noah, Herbelin Ludovic<br>
        <br>&nbsp;&nbsp;rendu le 04.12.18
    </header>
    <p>
      Le but de ce laboratoire était de déplacer des objets le long d'une courbe dans un univers en trois dimensions. Les éléments sont éclairés le long du chemin par des lumières ponctuelles que l'utilisateur peut allumer, éteindre et déplacer verticalement. <br/>
      <br/>
      <strong>Utiliser Firefox ou un petit serveur local pour contourner le protocole de sécurité de Chrome ("Cross origin requests") causé par l'importation de modèles 3D externes.</strong>
    </p>
    <div id="fps"></div>
    <canvas id="webgl-canvas" width="800" height="600">HTML5 is not supported</canvas>

    <br/>
    <div id="control-panel" style="display: inline-block;">
          <h1>Ajout de formes</h1><br/>
          <button id="btnAddCube" onclick="addCube(0.4, {r: 1.0, g: 0.0, b: 0.0, a: 0.8})" style="font-size:15px; width: 110px; height: 110px; white-space: normal;">
            Ajouter un cube
            <div id="btnAddCubeInfo" style="font-size: 11px; color: gray; padding: 0;"> </div>
          </button>
          <button id="btnAddTetrahedron" onclick="addTetrahedron(0.6, {r: 0.0, g: 1.0, b: 0.0, a: 0.8})" style="font-size:15px; width:110px; height: 110px; white-space: normal;">
            Ajouter un tétraèdre
            <div id="btnAddTetrahedronInfo" style="font-size: 11px; color: gray; padding: 0;"> </div>
          </button>
          <button id="btnAddSphere" onclick="addSphere(0.3, {r: 0.0, g: 1.0, b: 1.0, a: 0.8})" style="font-size:15px; width:110px; height: 110px; white-space: normal; padding: 0;">
            Ajouter une sphère
            <div id="btnAddSphereInfo" style="font-size: 11px; color: gray; padding: 0;"></div>
          </button>

          <br/><br/><h1>Gestion de la lumière</h1><br/>

          <div class="light-div">
            <input type="checkbox" checked onchange="toggleLight(0)" id="toggleLight1" />
            <span class="title"><label for="toggleLight1">Ampoule premier plan</label></span> <br>
            <span class="label">Position en Y : </span><input style="float: right; width:50%" type="range" step="0.1" id="light1Position" onchange="changeLightPos(0, this.value)" oninput="changeLightPos(0, this.value)"/>
            <div class="lightRepresentation-div" id="light1Representation" onclick="document.getElementById('toggleLight1').click()"></div>
          </div>

          <div class="light-div">
            <input type="checkbox" onchange="toggleLight(1)" id="toggleLight2" />
            <span class="title"><label for="toggleLight2">Ampoule de gauche</label></span> <br>
            <span class="label">Position en Y : </span><input style="float: right; width:50%" type="range" min=minLightHeight.toString() max=maxLightHeight.toString() value=lightPositions[1+1].toString() step="0.1" id="light2Position" onchange="changeLightPos(1, this.value)" oninput="changeLightPos(1, this.value)"/>
            <div class="lightRepresentation-div" id="light2Representation" onclick="document.getElementById('toggleLight2').click()"></div>
          </div>

          <div class="light-div">
            <input type="checkbox" onchange="toggleLight(2)" id="toggleLight3" />
            <span class="title"><label for="toggleLight3">Ampoule arrière p</label>lan</span> <br>
            <span class="label" >Position en Y : </span><input style="float: right; width:50%" type="range" min=minLightHeight.toString() max=maxLightHeight.toString() value=lightPositions[2+1].toString() step="0.1" id="light3Position" onchange="changeLightPos(2, this.value)" oninput="changeLightPos(2, this.value)"/>
            <div class="lightRepresentation-div" id="light3Representation" onclick="document.getElementById('toggleLight3').click()"></div>
          </div>

          <div class="light-div">
            <input type="checkbox" onchange="toggleLight(3)" id="toggleLight4" />
            <span class="title"><label for="toggleLight4">Ampoule de droite</label></span> <br>
            <span class="label" >Position en Y : </span><input style="float: right; width:50%" type="range" min=minLightHeight.toString() max=maxLightHeight.toString() value=lightPositions[3+1].toString() step="0.1" id="light4Position" onchange="changeLightPos(3, this.value)" oninput="changeLightPos(3, this.value)"/>
            <div class="lightRepresentation-div" id="light4Representation" onclick="document.getElementById('toggleLight4').click()"></div>
          </div>

          <input type="button" value="Inverser l'état de chaque ampoule" onclick="toggleAllLights()" style="font-size:15px; width: 175px; height: 65px; white-space: normal;" />
          <input type="button" value="Réinitialiser la position de chaque ampoule" onclick="resetLightsPosition()" style="font-size:15px; width: 175px; height: 65px; white-space: normal;" />
      </div>
    <div  style = "float: left;">
      <h3>Description détaillée</h3>
      <p>
        Nous avons choisi d'implémenter une structure orientée objet pour les modèles géométriques ajoutés à la scène. Nous n'avons cependant pas voulu implémenter une méthode "drawElements" dans chaque objet et de plutôt continuer à utiliser les buffers communs (vertices, colors, etc.) pour profiter de la parallélisation des tâches par le GPU.<br/>
        <br/>
        Nous avons implémenté une méthode permettant de définir une courbe de Bézier avec des points de contrôles fournis.<br/>
        <br/>
        Nous avons implémenté le modèle d'illumination de Phong adapté à plusieurs lumières ponctuelles.<br/>
        <br/>
        Finalement, nous avons implémenté la possibilité d'importer des modèles 3D externes (au format WaveFront : .OBJ). Actuellement, seulement la sphère est chargée de cette manière.<br/>
        <br/>
        Cette structure nous permet d'ajouter facilement n'importe quel objet 3D à la scène mais <strong>nécessite d'utiliser Firefox ou de créer un petit serveur local pour contourner le protocole de sécurité "Cross origin requests" de Chrome</strong>.<br/>
        <br/>
        <br/>
        Note à M.Gobron : concernant le problème de frame drop que nous avions, nous avons remarqué que nous appelions la méthode "initBuffers" après la transformation de chaque forme ce qui provoquait de gros ralentissements. Nous avons corrigé le problème en ne l'effectuant qu'une seule fois après avoir update toutes les formes de la scène.
      </p>
    </div>
  </body>
</html>
