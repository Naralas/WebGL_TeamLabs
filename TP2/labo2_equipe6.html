<<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="./css/stylesheet.css">
    <script src="./js/commonFunctions.js"></script>
    <script src="./js/gl-matrix-min.js"></script>
    <script src="./js/webglTools.js"></script>

    <script src="./SolidShape.js"></script>
    <script src="./Cube.js"></script>
    <script src="./Tetrahedron.js"></script>

    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
    	attribute vec4 aColor;
    	uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      uniform highp mat4 uNormalMatrix;
      varying vec4 vColor;     

      varying highp vec3 vLighting;

    	void main(void) {
  	    vColor = aColor;
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        

        // Apply lighting effect
    
        highp vec3 ambientLight = vec3(0.6, 0.6, 0.6);
        highp vec3 directionalLightColor = vec3(0.5, 0.5, 0.75);
        highp vec3 directionalVector = vec3(0.85, 0.8, 0.75);
        
        highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);
        
        highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);
        vLighting = ambientLight + (directionalLightColor * directional);
  	  }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
      #ifdef GL_ES
    		precision highp float;
    	#endif
      varying vec4 vColor;
      varying highp vec3 vLighting;
    	void main(void) {
    		gl_FragColor = vec4(vColor.rgb * vLighting, vColor.a);
    	}
    </script>

    <script>
      var vertexBuffer = null;
      var indexBuffer = null;
      var colorBuffer = null;

      var indices = [];
      var vertices = [];
      var colors = [];

      var mvMatrix = mat4.create();
      var pMatrix = mat4.create();
      var solidShapes = [];

      var cameraPos = [0.0, 0.0, -2.0];

      function initShaderParameters(prg) {
        prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
        glContext.enableVertexAttribArray(prg.vertexPositionAttribute);

        prg.colorAttribute = glContext.getAttribLocation(prg, "aColor");
        glContext.enableVertexAttribArray(prg.colorAttribute);

        prg.pMatrixUniform = glContext.getUniformLocation(prg, "uPMatrix");
        prg.mvMatrixUniform = glContext.getUniformLocation(prg, "uMVMatrix");
      }

      function initBuffers() {
        vertexBuffer = getVertexBufferWithVertices(vertices);
        colorBuffer = getVertexBufferWithVertices(colors);
        indexBuffer = getIndexBufferWithIndices(indices);
      }

      function drawScene() {
        glContext.clearColor(0.9, 0.9, 0.9, 1.0);
        glContext.enable(glContext.DEPTH_TEST);
        glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
        glContext.viewport(0, 0, c_width, c_height);

        mat4.identity(pMatrix);
        mat4.identity(mvMatrix);

        // mat4.rotate(mvMatrix, mvMatrix, degToRad(10), [0.0, 1.0, 0.0]);
        // mat4.rotate(mvMatrix, mvMatrix, degToRad(10), [0.0, 0.0, 1.0]);
        mat4.translate(mvMatrix, mvMatrix, cameraPos);

        const fieldOfView = degToRad(45);
        const aspect = glContext.canvas.clientWidth / glContext.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 100.0;

        mat4.perspective(pMatrix, fieldOfView, aspect, zNear, zFar);

        glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
        glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
        glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, colorBuffer);
        glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
        glContext.drawElements(glContext.TRIANGLES, indices.length, glContext.UNSIGNED_SHORT,0);


        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesNormalBuffer);
        gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

        var normalMatrix = mvMatrix.inverse();
        normalMatrix = normalMatrix.transpose();
        var nUniform = gl.getUniformLocation(shaderProgram, 'uNormalMatrix');
        gl.uniformMatrix4fv(nUniform, false, new WebGLFloatArray(normalMatrix.flatten()));
      }

      function initWebGL() {
        glContext = getGLContext('webgl-canvas');
        initProgram();
        initBuffers();
        renderLoop();
      }

      function addCube(width=0.5, center={x:0.0, y:0.0, z:0.0}, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        solidShapes.push(new Cube(vertices, indices, colors,
                                   width, center, color
                                 ));
        cubeVerticesNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesNormalBuffer);

        var vertexNormals = [
            // Front
            0.0,  0.0,  1.0,
            0.0,  0.0,  1.0,
            0.0,  0.0,  1.0,
            0.0,  0.0,  1.0,
            
            // Back
            0.0,  0.0, -1.0,
            0.0,  0.0, -1.0,
            0.0,  0.0, -1.0,
            0.0,  0.0, -1.0,
            
            // Top
            0.0,  1.0,  0.0,
            0.0,  1.0,  0.0,
            0.0,  1.0,  0.0,
            0.0,  1.0,  0.0,
            
            // Bottom
            0.0, -1.0,  0.0,
            0.0, -1.0,  0.0,
            0.0, -1.0,  0.0,
            0.0, -1.0,  0.0,
            
            // Right
            1.0,  0.0,  0.0,
            1.0,  0.0,  0.0,
            1.0,  0.0,  0.0,
            1.0,  0.0,  0.0,
            
            // Left
            -1.0,  0.0,  0.0,
            -1.0,  0.0,  0.0,
            -1.0,  0.0,  0.0,
            -1.0,  0.0,  0.0
        ];

        gl.bufferData(gl.ARRAY_BUFFER, new WebGLFloatArray(vertexNormals), gl.STATIC_DRAW);
        vertexBuffer = getVertexBufferWithVertices(vertices);
        colorBuffer = getVertexBufferWithVertices(colors);
        indexBuffer = getIndexBufferWithIndices(indices);
      }

      function addTetrahedron(width=0.5, center={x:0.0, y:0.0, z:0.0}, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        solidShapes.push(new Tetrahedron(vertices, indices, colors,
                                          width, center, color
                                        ));
         vertexBuffer = getVertexBufferWithVertices(vertices);
         colorBuffer = getVertexBufferWithVertices(colors);
         indexBuffer = getIndexBufferWithIndices(indices);
      }

      function moveElement(solidShape, newCenter) {
        solidShape.move(newCenter);
        vertexBuffer = getVertexBufferWithVertices(vertices);
      }

      function rotateElement(solidShape, angle, xAxis=true, yAxis=true, zAxis=true) {
        solidShape.rotate(angle, xAxis, yAxis, zAxis);
        vertexBuffer = getVertexBufferWithVertices(vertices);
      }
    </script>
  </head>
  <body onload="initWebGL()">
    <header>
        <h1>&nbsp;Infographie, Labo 2 - ...<br></h1>
        <br>&nbsp;&nbsp;Équipe 6 : Chacun Guillaume, Graells Noah, Herbelin Ludovic<br>
        <br>&nbsp;&nbsp;rendu le 27.11.18
    </header>
    <p>
      Le but du laboratoire était de ...
    </p>
    <canvas id="webgl-canvas" width="500" height="500">
      HTML5 is not supported
    </canvas>

    <div id="control-panel">
      <div class="user-input">
        <p>Ajouter un cube :</p>
        <input type="button" value="Ajouter un cube" onclick="addCube(0.2, {x: -.75, y: -.75, z: -.2}, {r: 0.6, g: 1.0, b: 0.7, a: 1.0})" />
        <p>Ajouter un tétraèdre :</p>
        <input type="button" value="Ajouter un tétraèdre" onclick="addTetrahedron(0.4, {x: .75, y: .75, z: -.2}, {r: 0.6, g: 1.0, b: 1.0, a: 1.0})" />
      </div>
    </div>
  </body>
</html>
>