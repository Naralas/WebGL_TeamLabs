<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="./css/stylesheet.css">
    <script src="./js/commonFunctions.js"></script>
    <script src="./js/gl-matrix-min.js"></script>
    <script src="./js/webglTools.js"></script>
		<script src="js/OBJ_loader.js"></script>

    <script src="./SolidShape.js"></script>
    <script src="./Cube.js"></script>
    <script src="./Tetrahedron.js"></script>
    <script src="./Sphere.js"></script>
    <script src="./ImportedModel.js"></script>

    <!-- Vertex Shader -->
    <script id="shader-vs" type="x-shader/x-vertex">
      #define NB_LIGHTS 4

      // vertex's attributes
      attribute vec3 aVertexPosition;
      attribute vec3 aVertexNormal;
      attribute vec4 aColor;

      // uniform variables
      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      uniform mat4 uNormalMatrix;
      uniform vec3 uViewPos;

      // varying variables
      varying vec4 vColor;   // vertex's color
      varying vec3 vNormal;  // vertex's normal
      varying vec3 vFragPos; // vertex's position
      varying vec3 vViewPos; // camera position


    	void main(void) {
        gl_PointSize = 15.0; // to display the lights
        vColor = aColor;
        vViewPos = uViewPos;
        vFragPos = aVertexPosition;

        // compute vertex's normal
        if (aVertexNormal != vec3(0.0,0.0,0.0)) {
          vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));
        } else {
          vNormal = vec3(0.0, 0.0, 0.0);
        }

        // compute vertex's position in camera coordinates system
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  	  }
    </script>

    <!-- Fragment Shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
      #ifdef GL_ES
    		precision highp float;
      #endif
      #define NB_LIGHTS 4

      // adapted from https://learnopengl.com/

      varying vec3 vNormal;  // vertex's normal
      varying vec4 vColor;   // vertex's color
      varying vec3 vFragPos; // vertex's position (world coordinates)
      varying vec3 vViewPos; // camera's position (world coordinates)

      uniform int uLightToggled[NB_LIGHTS];    // each light's position
      uniform vec3 uLightPositions[NB_LIGHTS]; // each light's state

      // lights constants parameters
      float materialShininess = 32.0;
      float lightConstant = 1.0;   // used to compute light's attenuation
      float lightLinear = 0.09;    // used to compute light's attenuation
      float lightQuadratic = 0.01; // used to compute light's attenuation
      vec3 lightAmbient = vec3(0.05, 0.05, 0.05);
      vec3 lightDifuse = vec3(0.8, 0.8, 0.8);
      vec3 lightSpecular = vec3(1.0, 1.0, 1.0);

      /*
      * Computes the final color of a fragment according to a specific point light.
      */
      vec3 calcPointLight(vec3 lightPos, vec3 normal, vec3 fragPos, vec3 viewDir, vec4 defaultColor) {
        vec3 lightDir = normalize(lightPos - fragPos); // light's direction

        // diffuse shading
        float diff = max(dot(normal, lightDir), 0.0);

        // specular shading
        vec3 reflectDir = reflect(-lightDir, normal);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), materialShininess);

        // attenuation
        float distance    = length(lightPos - fragPos);
        float attenuation = 1.0 / (lightConstant + lightLinear * distance + lightQuadratic * (distance * distance));

        // combine results
        vec3 ambient  = lightAmbient * defaultColor.rgb;
        vec3 diffuse  = lightDifuse * diff * defaultColor.rgb;
        vec3 specular = lightSpecular * spec * defaultColor.rgb;

        // apply attenuation
        ambient  *= attenuation;
        diffuse  *= attenuation;
        specular *= attenuation;

        // return combined light's effects
        return (ambient + diffuse + specular);
      }

      void main(void) {
        vec4 defaultColor = vec4(vColor.rgb, 1.0);

        vec3 norm = normalize(vNormal);
        vec3 viewDir = normalize(vViewPos - vFragPos);
        vec3 result = vec3(0.0, 0.0, 0.0);

        // if this isn't part of the curve
        if(vNormal != vec3(0.0, 0.0, 0.0)) {
          // compute the sub-color value for each enabled light
          for(int i=0; i<NB_LIGHTS; i++) {
            if (uLightToggled[i] == 1) {
              //vec3 lightPos = vec3(0.0, 1.0, 0.0);
              vec3 lightPos = uLightPositions[i];
              result += calcPointLight(lightPos, norm, vFragPos, viewDir, defaultColor);
            }
          }

          gl_FragColor = vec4(result, 1.0);
        } else {
          gl_FragColor = defaultColor;
        }
      }
    </script>

    <script>
      // buffers
      var vertexBuffer = null;
      var indexBuffer = null;
      var colorBuffer = null;
      var normalBuffer = null;

      // scene geometry
      var indices = [];
      var vertices = [];
      var colors = [];
      var normals = [];

      // camera
      var mvMatrix = mat4.create();
      var pMatrix = mat4.create();
      var cameraPos = [4.0, -2.5, -6.0];

      // scene
      var solidShapes = [];
      var path = [];
      var drawPath = true;
      var lastTime = performance.now();
      const maxNumberOfSolidShapes = 100;
      var nbImportedModels = 0;
      const maxNumberImportedModels = 15;
      var frameCount = 0;
      var elapsedTime = 0;

      // render
      const fieldOfView = degToRad(45);
      const zNear = 0.1;
      const zFar = 100.0;
      var aspect;

      // lights
      var lightsVerticesOffset = 0;
      var lightsColorsOffset = 0;
      const lightColorOn = {r: 1.0, g: 1.0, b: 0.0, a: 1.0};
      const lightColorOff = {r: 0.0, g: 0.0, b: 0.0, a: 1.0};

      const lightEmitColorOn = {r: 0.1, g: 0.1, b: 0.1};
      const lightEmitColorOff = {r: 0.0, g: 0.0, b: 0.0};

      var lightPositions = [];
      var lightToggled = [];

      const minLightHeight = 0.3;
      const maxLightHeight = 3.5;

      // cooldown to add objects
      var currCooldownAddObject = 0;
      const cooldownAddObject = 500;

      // models
      var importedModels = [];

      /**
      * Creates the "bridges" between JS and the GLSL program (shaders) "prg".
      */
      function initShaderParameters(prg) {
        prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
        prg.vertexNormalAttribute   = glContext.getAttribLocation(prg, "aVertexNormal");
        prg.colorAttribute          = glContext.getAttribLocation(prg, "aColor");

        glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
        glContext.enableVertexAttribArray(prg.vertexNormalAttribute);
        glContext.enableVertexAttribArray(prg.colorAttribute);

        prg.pMatrixUniform        = glContext.getUniformLocation(prg, "uPMatrix");
        prg.mvMatrixUniform       = glContext.getUniformLocation(prg, "uMVMatrix");
        prg.nUniform              = glContext.getUniformLocation(prg, "uNormalMatrix");
        prg.lightPositionsUniform = glContext.getUniformLocation(prg, "uLightPositions");
        prg.lightToggledUniform   = glContext.getUniformLocation(prg, "uLightToggled");
        prg.viewPosUniform        = glContext.getUniformLocation(prg, "uViewPos");
      }

      /**
      * Buffers initialization to send vertices and index data to the shaders.
      */
      function initBuffers() {
        vertexBuffer  = getVertexBufferWithVertices(vertices);
        normalBuffer  = getVertexBufferWithVertices(normals);
        colorBuffer   = getVertexBufferWithVertices(colors);
        indexBuffer   = getIndexBufferWithIndices(indices);
      }

      /**
      * Draws and initializes the scene.
      */
      function drawScene() {
        // for each solid shape, rotate and move it as long as its on the path
        for (let i=solidShapes.length-1; i>=0; i--) {
          if (vec3.distance(vec3.fromValues(solidShapes[i].center.x, solidShapes[i].center.y, solidShapes[i].center.z), vec3.fromValues(0,0,0)) > 7)
            removeElement(solidShapes[i], i);

          if (!ImportedModel.prototype.isPrototypeOf(solidShapes[i])) // desable rotations for imported models to avoid perfomance loss
            rotateElement(solidShapes[i], 0.3, true, true, true, false); // rotate 1 degree on each axis
          moveAlongPath(solidShapes[i], performance.now() - lastTime, i); // move elements along the BÃ©zier curve
        }

        // update buffers
        if (solidShapes.length > 0) {
          vertexBuffer  = getVertexBufferWithVertices(vertices);
          normalBuffer  = getVertexBufferWithVertices(normals);
        }

        // draw fps
        drawFps();

        // draw cooldown
        if (currCooldownAddObject > 0) {
          currCooldownAddObject -= performance.now() - lastTime;
          handleBtnCooldown();
        }

        lastTime = performance.now();

        // init scene
        glContext.clearColor(0.0, 0.0, 0.0, 1.0);
        glContext.enable(glContext.DEPTH_TEST);
        glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
        glContext.viewport(0, 0, c_width, c_height);

        mat4.identity(pMatrix);
        mat4.identity(mvMatrix);

        // sets camera position / orientation
        mat4.rotate(mvMatrix, mvMatrix, degToRad(15), [1.0, 0.0, 0.0]);
        mat4.rotate(mvMatrix, mvMatrix, degToRad(35), [0.0, 1.0, 0.0]);
        mat4.translate(mvMatrix, mvMatrix, cameraPos);

        // sets the perspective
        mat4.perspective(pMatrix, fieldOfView, aspect, zNear, zFar);

        // send the camera matrices
        glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
        glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);

        // send the lights position
        glContext.uniform3fv(prg.lightPositionsUniform, lightPositions);

        // send the lights state
        glContext.uniform1iv(prg.lightToggledUniform, lightToggled);

        // send the camera's position
        glContext.uniform3f(prg.viewPosUniform, cameraPos[0], cameraPos[1], cameraPos[2]);

        // normal matrix
        let normalMatrix = mat4.create();
        mat4.invert(normalMatrix, mvMatrix);
        normalMatrix = mat4.transpose(normalMatrix, normalMatrix);
        glContext.uniformMatrix4fv(prg.nUniform, false, normalMatrix);

        // buffers
        glContext.bindBuffer(glContext.ARRAY_BUFFER, normalBuffer);
        glContext.vertexAttribPointer(prg.vertexNormalAttribute, 3, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
        glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, colorBuffer);
        glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);

        // draw elements
        let numberLightsPoints = 4;
        if (drawPath) {
          glContext.drawElements(glContext.LINE_STRIP, path.length, glContext.UNSIGNED_SHORT, 0); // draw path
          glContext.drawElements(glContext.POINTS, numberLightsPoints, glContext.UNSIGNED_SHORT, path.length * 2); // draw lights
          glContext.drawElements(glContext.TRIANGLES, indices.length-path.length-numberLightsPoints, glContext.UNSIGNED_SHORT, (path.length) * 2 + numberLightsPoints * 2); // draw scene
        } else {
          glContext.drawElements(glContext.POINTS, numberLightsPoints, glContext.UNSIGNED_SHORT, 0); // draw lights
          glContext.drawElements(glContext.TRIANGLES, indices.length-numberLightsPoints, glContext.UNSIGNED_SHORT, numberLightsPoints * 2); // draw scene
        }
      }

      /**
      * Initializes the webgl program.
      */
      function initWebGL() {
        glContext = getGLContext("webgl-canvas");
        aspect = glContext.canvas.clientWidth / glContext.canvas.clientHeight;
        initProgram();

        // intialize scene ahd DOM
        initPath(35); // Initializes the path
        initStaticScene(); // Initializes the static scene
        initLightsSliders();
        displayAvailableComplexObjects();
        displayAvailableSimpleObjects();

        // load external models
        loadModel("models/sphere.obj");

        // start webgl application
        initBuffers();
        renderLoop();
      }

      /**
      * Handles button add complex object cooldown.
      */
      function handleBtnCooldown() {
        if (currCooldownAddObject > 0) {
          document.getElementById("btnAddSphere").disabled = true;
          let s = Math.round((currCooldownAddObject / 1000) * 100) / 100;
          document.getElementById("btnAddSphereInfo").innerHTML = "(" + s + " s)";
        } else {
          document.getElementById("btnAddSphere").disabled = false;
          document.getElementById("btnAddSphereInfo").innerHTML = "";
          displayAvailableComplexObjects();
        }
      }

      /**
      * Displays available number of complex objects to add to the scene.
      */
      function displayAvailableComplexObjects() {
        document.getElementById("btnAddSphereInfo").innerHTML = "(" + (maxNumberImportedModels-nbImportedModels) + " disponibles)";
        document.getElementById("btnAddSphere").disabled = maxNumberImportedModels-nbImportedModels <= 0 && maxNumberOfSolidShapes-solidShapes.length;
      }

      /**
      * Display available solid shapes to add to the scene.
      */
      function displayAvailableSimpleObjects() {
        document.getElementById("btnAddCubeInfo").innerHTML = "(" + (maxNumberOfSolidShapes-solidShapes.length) + " disponibles)";
        document.getElementById("btnAddTetrahedronInfo").innerHTML = "(" + (maxNumberOfSolidShapes-solidShapes.length) + " disponibles)";
        document.getElementById("btnAddCube").disabled = maxNumberOfSolidShapes-solidShapes.length <= 0;
        document.getElementById("btnAddTetrahedron").disabled = maxNumberOfSolidShapes-solidShapes.length <= 0;
        document.getElementById("btnAddSphere").disabled = maxNumberImportedModels-nbImportedModels <= 0 && maxNumberOfSolidShapes-solidShapes.length <= 0;
      }

      /**
      * Computes and draws FPS.
      */
      function drawFps() {
        frameCount++;
        elapsedTime += (performance.now() - lastTime);
        if(elapsedTime >= 1000) {
          fps = frameCount;
          frameCount = 0;
          elapsedTime -= 1000;

          document.getElementById("fps").innerHTML = fps + " fps";
        }
      }

      /**
      * Adds a new cube to the scene on the path's origin.
      */
      function addCube(width=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes) {
          solidShapes.push(new Cube(vertices, indices, colors, normals,
                                     width, {x: path[0][0], y: path[0][1], z: path[0][2]}, color
                                   ));
          displayAvailableSimpleObjects();
          initBuffers();
        } else
         console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Adds a new tetrahedron to the scene on the path's origin.
      */
      function addTetrahedron(width=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes) {
          solidShapes.push(new Tetrahedron(vertices, indices, colors, normals,
                                            width, {x: path[0][0], y: path[0][1], z: path[0][2]}, color
                                          ));
          displayAvailableSimpleObjects();
          initBuffers();
         } else
          console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Adds a new sphere to the scene on the path's origin.
      */
      function addSphere(width=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes) {
          if (nbImportedModels < maxNumberImportedModels) {
            nbImportedModels++;
            displayAvailableComplexObjects();
            addImportedModel(importedModels[0].finalVertices, importedModels[0].finalNormals, 0.2, {r:0.0, g:1.0, b:1.0, a:1.0});
          } else
            console.log("You can add at most " + maxNumberImportedModels + " complicated models to the scene.");
        } else
          console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Adds a new imported model to the scene on the path's origin.
      */
      function addImportedModel(presetVertices, presetNormals, ratioSize=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes && currCooldownAddObject <= 0) {
          solidShapes.push(new ImportedModel(vertices, indices, colors, normals, presetVertices, presetNormals,
                                        ratioSize, {x: path[0][0], y: path[0][1], z: path[0][2]}, color
                                      ));
          currCooldownAddObject = cooldownAddObject;
          displayAvailableSimpleObjects();
          initBuffers();
         } else
          console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Moves the given solid shape to a new center.
      */
      function moveElement(solidShape, newCenter, updateBuffers=true) {
        solidShape.move(newCenter);
        if (updateBuffers)
          vertexBuffer = getVertexBufferWithVertices(vertices);
      }

      /**
      * Rotates the given solid shape of a given angle around the specified axis.
      */
      function rotateElement(solidShape, angle, xAxis=true, yAxis=true, zAxis=true, updateBuffers=true) {
        solidShape.rotate(angle, xAxis, yAxis, zAxis);
        if (updateBuffers) {
          vertexBuffer  = getVertexBufferWithVertices(vertices);
          normalBuffer  = getVertexBufferWithVertices(normals);
        }
      }

      /**
      * Removes the given solid shape (at given index in the solidShapes array) from the scene
      * and the solidShapes array. Updates the offsets of each remaining solid shape.
      */
      function removeElement(solidShape, index) {
        if (ImportedModel.prototype.isPrototypeOf(solidShape)) {
          nbImportedModels--;
          displayAvailableComplexObjects();
        }
        solidShape.delete(); // removes the shape's values from the shared arrays (vertices, indices, colors)
        for (let i=index+1; i<solidShapes.length; i++) // updates each remaining solid shape's offsets in shared arrays
        solidShapes[i].updateOffsets(solidShapes[index].numberVertices*3,
        solidShapes[index].numberIndices,
        solidShapes[index].numberVertices*4);
        solidShapes.splice(index, 1); // remove the solid shape from the solidShapes array
        displayAvailableSimpleObjects();
        initBuffers();
      }

      /**
      * Moves the given solid along the path.
      */
      function moveAlongPath(solidShape, dt, index) {
        let delta = solidShape.speed * dt / 1000; // computes the step for this iteration

        let dir = vec3.create();

        // retrieves the current position and creates the direction vector (destination - current pos)
        let currPos = vec3.fromValues(solidShape.center.x, solidShape.center.y, solidShape.center.z);
        vec3.sub(dir, path[solidShape.lastPathPoint+1], currPos);
        vec3.normalize(dir, dir); // normalize the direction
        vec3.scale(dir, dir, delta); // multiply the direction vector by the step

        let newPos = vec3.create();
        vec3.add(newPos, currPos, dir); // new position is the old one added to the movement vector

        // moves the solid shape to its new position
        moveElement(solidShape, {x: newPos[0], y: newPos[1], z: newPos[2]}, false);

        // if the distance between the current position and our goal is smaller than an error
        if (vec3.distance(currPos, path[solidShape.lastPathPoint+1]) < solidShape.positionComparaisonError) {
          solidShape.lastPathPoint++; // increment the path's control point id

          // move the solid shape to the path's control point (to avoid accumulating errors)
          moveElement(solidShape, {x: path[solidShape.lastPathPoint][0], y: path[solidShape.lastPathPoint][1], z: path[solidShape.lastPathPoint][2]});

          // if the last path's control point has been reached
          if (solidShape.lastPathPoint >= path.length-1)
            removeElement(solidShape, index); // remove the solid shape
        }
      }

      /**
      * Changes the given light's position.
      */
      function changeLightPos(lightNumber, newPos) {
        vertices[lightsVerticesOffset + lightNumber * 3 + 1] = parseFloat(newPos);
        vertexBuffer = getVertexBufferWithVertices(vertices);

        lightPositions[lightNumber * 3 + 1] = parseFloat(newPos);
      }

      /**
      * Toggles on and off the given light's id.
      */
      function toggleLight(lightNumber) {
        let offset = lightsColorsOffset + (lightNumber * 4);

        // change light's color
        colors[offset + 0] = lightToggled[lightNumber] == 1 ? lightColorOff.r : lightColorOn.r;
        colors[offset + 1] = lightToggled[lightNumber] == 1 ? lightColorOff.g : lightColorOn.g;
        colors[offset + 2] = lightToggled[lightNumber] == 1 ? lightColorOff.b : lightColorOn.b;
        colors[offset + 3] = lightToggled[lightNumber] == 1 ? lightColorOff.a : lightColorOn.a;
        colorBuffer = getVertexBufferWithVertices(colors);

        // toggle light's state
        lightToggled[lightNumber] = lightToggled[lightNumber] == 0 ? 1 : 0;

        // toggle light's html representation
        document.getElementById("light" + (lightNumber+1) + "Representation").style.backgroundColor = lightToggled[lightNumber] == 1 ? "yellow" : "black";
      }

      /**
      * Toggles on and off the each scene's light.
      */
      function toggleAllLights() {
        for (let i=0; i<4; i++) {
          toggleLight(i);
          document.getElementById("toggleLight" + (i+1)).checked = lightToggled[i] == 1;
        }
      }

      /**
      * Resets each scene's light position.
      */
      function resetLightsPosition() {
        for (let i=0; i<4; i++) {
          changeLightPos(i, minLightHeight);
          document.getElementById("light" + (i+1) + "Position").value = minLightHeight;
        }
      }

      /**
      * Initializes the static objects on the scene.
      */
      function initStaticScene() {
        let groundCenter = {x: 0.0, y: 0.0, z: 0.0};
        let groundSize = {width: 5.5, depth: 5.5};

        initSceneLights();

        let indicesOffset = indices.length;
        // ground
        vertices.push(groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2, // P0
                      groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P1
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P2
                      groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2, // P0
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P2
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2  // P3
                    );
        indices.push(indicesOffset+0, indicesOffset+1, indicesOffset+2,
                     indicesOffset+3, indicesOffset+4, indicesOffset+5);
        colors.push(0.6, 0.6, 0.6, 1.0, // P0
                    0.6, 0.6, 0.6, 1.0, // P1
                    0.6, 0.6, 0.6, 1.0, // P2
                    0.6, 0.6, 0.6, 1.0, // P3
                    0.6, 0.6, 0.6, 1.0, // P4
                    0.6, 0.6, 0.6, 1.0  // P5
                  );
        normals.push(0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0);

        // walls
        // let wallHeight = 5.0;
        // vertices.push(groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2,
        //               groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2,
        //               groundCenter.x + groundSize.width/2, groundCenter.y + wallHeight, groundCenter.z + groundSize.depth/2,
        //               groundCenter.x + groundSize.width/2, groundCenter.y + wallHeight, groundCenter.z - groundSize.depth/2,
        //               groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2,
        //               groundCenter.x - groundSize.width/2, groundCenter.y + wallHeight, groundCenter.z - groundSize.depth/2);
        // indices.push(indicesOffset+4, indicesOffset+5, indicesOffset+6,
        //              indicesOffset+4, indicesOffset+6, indicesOffset+7,
        //              indicesOffset+8, indicesOffset+4, indicesOffset+7,
        //              indicesOffset+8, indicesOffset+7, indicesOffset+9);
        // colors.push(0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0);
        // normals.push(0.0, 0.0, 0.0, 0.0,
        //              0.0, 0.0, 0.0, 0.0,
        //              0.0, 0.0, 0.0, 0.0,
        //              0.0, 0.0, 0.0, 0.0);
      }

      /**
      * Initializes the static lights objects on the scene.
      */
      function initSceneLights() {
        let lightRectangleCenter = {x: 0.0, y: 0.0, z: 0.0};
        let lightRectangleSize = {width: 5.0, depth: 5.0};

        lightsVerticesOffset = vertices.length;
        lightsColorsOffset = colors.length;
        let indicesOffset = indices.length;
        vertices.push(lightRectangleCenter.x - lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z + lightRectangleSize.depth/2, // P0
                      lightRectangleCenter.x - lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z - lightRectangleSize.depth/2, // P1
                      lightRectangleCenter.x + lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z - lightRectangleSize.depth/2, // P2
                      lightRectangleCenter.x + lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z + lightRectangleSize.depth/2  // P3
                    );
        lightPositions.push(lightRectangleCenter.x - lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z + lightRectangleSize.depth/2, // P0
                            lightRectangleCenter.x - lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z - lightRectangleSize.depth/2, // P1
                            lightRectangleCenter.x + lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z - lightRectangleSize.depth/2, // P2
                            lightRectangleCenter.x + lightRectangleSize.width/2, minLightHeight, lightRectangleCenter.z + lightRectangleSize.depth/2  // P3
                          );
        lightToggled.push(1,1,1,1);


        indices.push(indicesOffset+0, indicesOffset+1, indicesOffset+2, indicesOffset+3);
        colors.push(lightColorOn.r, lightColorOn.g, lightColorOn.b, lightColorOn.a,  // P0
                    lightColorOn.r, lightColorOn.g, lightColorOn.b, lightColorOn.a,  // P1
                    lightColorOn.r, lightColorOn.g, lightColorOn.b, lightColorOn.a,  // P2
                    lightColorOn.r, lightColorOn.g, lightColorOn.b, lightColorOn.a,  // P3
                  );
        normals.push(0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0
                   );

        toggleLight(0);toggleLight(0);
        toggleLight(1);
        toggleLight(2);
        toggleLight(3);
      }

      /**
      * Initializes the path (BÃ©zier curve) which will be followed by the solid shapes.
      */
      function initPath(numberIterations) {
        // set control points (first is origin and last is goal)
        let controlPoints = [vec3.fromValues( 4.9, 0.1, -4.9),
                             vec3.fromValues( 0.0, 0.2, -4.9),
                             vec3.fromValues(-4.9, 0.5, -4.9),
                             vec3.fromValues(-4.9, 1.4,  0.0),
                             vec3.fromValues(-4.9, 1.5,  6.9),
                             vec3.fromValues( 0.0, 1.6,  4.9),
                             vec3.fromValues( 4.9, 1.7,  4.9),
                             vec3.fromValues( 4.9, 1.7,  0.0),
                             vec3.fromValues( 4.9, 2.1, -4.9),
                             vec3.fromValues( 0.0, 2.3, -4.9),
                             vec3.fromValues(-4.9, 2.5, -4.9),
                             vec3.fromValues(-2.9, 2.7,  0.0),
                             vec3.fromValues(-2.9, 3.4,  1.5)] ;

        const inc = 1/numberIterations; // sets the delta for the BÃ©zier curve

        for (let t=0; t<1; t+=inc) // computes cuve points
          castelJau(t, controlPoints, controlPoints.length);
        path.reverse();

        // adds points to webgl arrays
        if (drawPath) {
          for (let i=0; i<path.length; i++) {
            vertices.push(path[i][0], path[i][1], path[i][2]);
            indices.push(i);
            colors.push(1.0, 0.0, 0.5, 0.2);
            normals.push(0.0, 0.0, 0.0);
          }
        }
      }

      /**
      * Castlejau implementation adapted from : http://fvirtman.free.fr/recueil/02_03_09_bezier.c.php
      * Used to create a BÃ©zier curve with given control points.
      */
      function castelJau(t, controlPoints, nbPoints) {
        let subtab = [];
        if (nbPoints == 1) {
          path.push(controlPoints[0]);
          return;
        }
        for (let i=0; i<nbPoints-1; i++)
          subtab.push(vec3.fromValues(t * controlPoints[i][0] + (1-t) * controlPoints[i+1][0],
                                      t * controlPoints[i][1] + (1-t) * controlPoints[i+1][1],
                                      t * controlPoints[i][2] + (1-t) * controlPoints[i+1][2]));
        castelJau(t, subtab, nbPoints-1);
      }

      /**
      * Initializes lights slides min, max and value.
      */
      function initLightsSliders() {
        for (let i=0; i<4; i++) {
          document.getElementById("light" + (i+1) + "Position").min = minLightHeight.toString();
          document.getElementById("light" + (i+1) + "Position").max = maxLightHeight.toString();
          document.getElementById("light" + (i+1) + "Position").value = lightPositions[(i*3)+1].toString();
        }
      }

      /**
      * Creates an object from the loaded wavefrom model.
      * Adapted code from book "WebGL par la pratique".
      */
      function handleOBJModel(filename, data){
        let objData = new OBJ.Mesh(data);

        let finalVertices = [];
        let finalNormals = [];

        // convert imported object geometry to our format
        for (let i=0; i<objData.indices.length; i++) {
          finalVertices.push(parseFloat(objData.vertices[objData.indices[i]*3 + 0]),
                             parseFloat(objData.vertices[objData.indices[i]*3 + 1]),
                             parseFloat(objData.vertices[objData.indices[i]*3 + 2]));
          finalNormals.push(parseFloat(objData.vertexNormals[objData.indices[i]*3 + 0]),
                            parseFloat(objData.vertexNormals[objData.indices[i]*3 + 1]),
                            parseFloat(objData.vertexNormals[objData.indices[i]*3 + 2]));
        }

        if (finalVertices.length > 0 && finalNormals.length > 0)
          importedModels.push({name: "sphere", finalVertices: finalVertices, finalNormals: finalNormals});
        document.getElementById("btnAddSphere").disabled = importedModels.length <= 0;
      }

      /**
      * Loads given model from filename.
      * Code from book "WebGL par la pratique".
      */
      function loadModel(filename) {
        let request = new XMLHttpRequest();
        request.open("GET", filename);
        request.onreadystatechange = function() {
          if (request.readyState == 4) {
            if(request.status == 404)
              console.info(filename + ' does not exist');
            else {
              let re = /(?:\.([^./]+))?$/;
              let ext = re.exec(filename)[1];
              if (ext == "obj")
                handleOBJModel(filename, request.responseText);
              else
                console.info("unknown format extension: " + ext );
            }
          }
        }
        request.send();
      }

    </script>

    <style>
      .light-div{
        padding: 5px;
        border: 1px solid #CCC;
        border-radius: 4px;
        vertical-align: middle;
        margin-bottom: 10px;
        width: 350px;
      }

      .title{
        line-height: 25px;
        font-weight: bold;
      }

      .label{
        line-height: 25px;
        margin-left: 25px;
      }

      .lightRepresentation-div {
        width: 20px;
        height: 20px;
        display: inline-block;
        float: left;
        border-radius: 2px;
        border: 1px solid lightgray;
      }

      .lightRepresentation-div:hover {
        cursor: pointer;
      }
    </style>

  </head>
  <body onload="initWebGL()">
    <header>
        <h1>&nbsp;Infographie, Labo 2 - Ãclairage d'objets 3D animÃ©s sur une courbe<br></h1>
        <br>&nbsp;&nbsp;Ãquipe 6 : Chacun Guillaume, Graells Noah, Herbelin Ludovic<br>
        <br>&nbsp;&nbsp;rendu le 04.12.18
    </header>
    <p>
      Le but de ce laboratoire Ã©tait de dÃ©placer des objets le long d'une courbe dans un univers en trois dimensions. Les Ã©lÃ©ments sont Ã©clairÃ©s le long du chemin par des lumiÃ¨res ponctuelles que l'utilisateur peut allumer, Ã©teindre et dÃ©placer verticalement. <br/>
      <br/>
      <strong>Utiliser Firefox ou un petit serveur local pour contourner le protocole de sÃ©curitÃ© de Chrome ("Cross origin requests") causÃ© par l'importation de modÃ¨les 3D externes.</strong>
    </p>
    <div id="fps"></div>
    <canvas id="webgl-canvas" width="800" height="600">HTML5 is not supported</canvas>

    <br/>
    <div id="control-panel" style="display: inline-block;">
          <h1>Ajout de formes</h1><br/>
          <button id="btnAddCube" onclick="addCube(0.4, {r: 1.0, g: 0.0, b: 0.0, a: 0.8})" style="font-size:15px; width: 110px; height: 110px; white-space: normal;">
            Ajouter un cube
            <div id="btnAddCubeInfo" style="font-size: 11px; color: gray; padding: 0;"> </div>
          </button>
          <button id="btnAddTetrahedron" onclick="addTetrahedron(0.6, {r: 0.0, g: 1.0, b: 0.0, a: 0.8})" style="font-size:15px; width:110px; height: 110px; white-space: normal;">
            Ajouter un tÃ©traÃ¨dre
            <div id="btnAddTetrahedronInfo" style="font-size: 11px; color: gray; padding: 0;"> </div>
          </button>
          <button id="btnAddSphere" onclick="addSphere(0.3, {r: 0.0, g: 1.0, b: 1.0, a: 0.8})" style="font-size:15px; width:110px; height: 110px; white-space: normal; padding: 0;">
            Ajouter une sphÃ¨re
            <div id="btnAddSphereInfo" style="font-size: 11px; color: gray; padding: 0;"></div>
          </button>

          <br/><br/><h1>Gestion de la lumiÃ¨re</h1><br/>

          <div class="light-div">
            <input type="checkbox" checked onchange="toggleLight(0)" id="toggleLight1" />
            <span class="title"><label for="toggleLight1">Ampoule premier plan</label></span> <br>
            <span class="label">Position en Y : </span><input style="float: right; width:50%" type="range" step="0.1" id="light1Position" onchange="changeLightPos(0, this.value)" oninput="changeLightPos(0, this.value)"/>
            <div class="lightRepresentation-div" id="light1Representation" onclick="document.getElementById('toggleLight1').click()"></div>
          </div>

          <div class="light-div">
            <input type="checkbox" onchange="toggleLight(1)" id="toggleLight2" />
            <span class="title"><label for="toggleLight2">Ampoule de gauche</label></span> <br>
            <span class="label">Position en Y : </span><input style="float: right; width:50%" type="range" min=minLightHeight.toString() max=maxLightHeight.toString() value=lightPositions[1+1].toString() step="0.1" id="light2Position" onchange="changeLightPos(1, this.value)" oninput="changeLightPos(1, this.value)"/>
            <div class="lightRepresentation-div" id="light2Representation" onclick="document.getElementById('toggleLight2').click()"></div>
          </div>

          <div class="light-div">
            <input type="checkbox" onchange="toggleLight(2)" id="toggleLight3" />
            <span class="title"><label for="toggleLight3">Ampoule arriÃ¨re p</label>lan</span> <br>
            <span class="label" >Position en Y : </span><input style="float: right; width:50%" type="range" min=minLightHeight.toString() max=maxLightHeight.toString() value=lightPositions[2+1].toString() step="0.1" id="light3Position" onchange="changeLightPos(2, this.value)" oninput="changeLightPos(2, this.value)"/>
            <div class="lightRepresentation-div" id="light3Representation" onclick="document.getElementById('toggleLight3').click()"></div>
          </div>

          <div class="light-div">
            <input type="checkbox" onchange="toggleLight(3)" id="toggleLight4" />
            <span class="title"><label for="toggleLight4">Ampoule de droite</label></span> <br>
            <span class="label" >Position en Y : </span><input style="float: right; width:50%" type="range" min=minLightHeight.toString() max=maxLightHeight.toString() value=lightPositions[3+1].toString() step="0.1" id="light4Position" onchange="changeLightPos(3, this.value)" oninput="changeLightPos(3, this.value)"/>
            <div class="lightRepresentation-div" id="light4Representation" onclick="document.getElementById('toggleLight4').click()"></div>
          </div>

          <input type="button" value="Inverser l'Ã©tat de chaque ampoule" onclick="toggleAllLights()" style="font-size:15px; width: 175px; height: 65px; white-space: normal;" />
          <input type="button" value="RÃ©initialiser la position de chaque ampoule" onclick="resetLightsPosition()" style="font-size:15px; width: 175px; height: 65px; white-space: normal;" />
      </div>
    <div  style = "float: left;">
      <h3>Description dÃ©taillÃ©e</h3>
      <p>
        Nous avons choisi d'implÃ©menter une structure orientÃ©e objet pour les modÃ¨les gÃ©omÃ©triques ajoutÃ©s Ã  la scÃ¨ne. Nous n'avons cependant pas voulu implÃ©menter une mÃ©thode "drawElements" dans chaque objet et de plutÃ´t continuer Ã  utiliser les buffers communs (vertices, colors, etc.) pour profiter de la parallÃ©lisation des tÃ¢ches par le GPU.<br/>
        <br/>
        Nous avons implÃ©mentÃ© une mÃ©thode permettant de dÃ©finir une courbe de BÃ©zier avec des points de contrÃ´les fournis.<br/>
        <br/>
        Nous avons implÃ©mentÃ© le modÃ¨le d'illumination de Phong adaptÃ© Ã  plusieurs lumiÃ¨res ponctuelles.<br/>
        <br/>
        Finalement, nous avons implÃ©mentÃ© la possibilitÃ© d'importer des modÃ¨les 3D externes (au format WaveFront : .OBJ). Actuellement, seulement la sphÃ¨re est chargÃ©e de cette maniÃ¨re.<br/>
        <br/>
        Cette structure nous permet d'ajouter facilement n'importe quel objet 3D Ã  la scÃ¨ne mais <strong>nÃ©cessite d'utiliser Firefox ou de crÃ©er un petit serveur local pour contourner le protocole de sÃ©curitÃ© "Cross origin requests" de Chrome</strong>.<br/>
        <br/>
        <br/>
        Note Ã  M.Gobron : concernant le problÃ¨me de frame drop que nous avions, nous avons remarquÃ© que nous appelions la mÃ©thode "initBuffers" aprÃ¨s la transformation de chaque forme ce qui provoquait de gros ralentissements. Nous avons corrigÃ© le problÃ¨me en ne l'effectuant qu'une seule fois aprÃ¨s avoir update toutes les formes de la scÃ¨ne.
      </p>
    </div>
  </body>
</html>
