<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="./css/stylesheet.css">
    <script src="./js/commonFunctions.js"></script>
    <script src="./js/gl-matrix-min.js"></script>
    <script src="./js/webglTools.js"></script>

    <script src="./SolidShape.js"></script>
    <script src="./Cube.js"></script>
    <script src="./Tetrahedron.js"></script>

    <!-- Vertex Shader -->
    <script id="shader-vs" type="x-shader/x-vertex">
      #define NB_LIGHTS 4

      attribute vec3 aVertexPosition;
      attribute vec3 aVertexNormal;
      attribute vec4 aColor;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      uniform mat4 uNormalMatrix;


      uniform vec3 uLightPositions[NB_LIGHTS];

      varying vec4 vColor;
      varying vec3 vNormal;
      varying vec3 vLightRay[NB_LIGHTS];
      varying vec3 vEyeVec;


    	void main(void) {
        gl_PointSize = 15.0;
        vColor = aColor;

        vec4 vertex = uMVMatrix * vec4(aVertexPosition, 1.0);
        if (aVertexNormal != vec3(0.0,0.0,0.0))
        {
          for(int i = 0; i < NB_LIGHTS; i++)
            vLightRay[i] = vertex.xyz - uLightPositions[i];

          vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));
          vEyeVec = -vec3(vertex.xyz);
        }
        else
          vNormal = vec3(0.0, 0.0, 0.0);

				gl_Position = uPMatrix * vertex;
  	  }
    </script>

    <!-- Fragment Shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
      #ifdef GL_ES
    		precision highp float;
      #endif
      #define NB_LIGHTS 4

      varying vec4 vColor;
      varying vec3 vNormal;

      uniform vec3 uMaterialDiffuse;
			uniform vec3 uMaterialSpecular;
      uniform float uShininess;

      varying vec3 vLightRay[NB_LIGHTS];
      varying vec3 vEyeVec;
      uniform bool uLightToggled[NB_LIGHTS];

      vec3 phongShading()
			{
        vec3 finalColor = vColor.rgb;



        for(int i = 0; i < NB_LIGHTS; i++)
        {
          if(uLightToggled[i])
          {
            vec3 N = normalize(vNormal);
            vec3 L = normalize(vLightRay[i]);
            float lambertTerm = dot(N,-L);

            if(lambertTerm > 0.0)
            {
              finalColor += uMaterialDiffuse * lambertTerm;

              vec3 R = reflect(L, N);
              vec3 E = normalize(vEyeVec);
              float specular = pow( max(dot(R, E), 0.0), uShininess);
              finalColor += uMaterialSpecular * specular;
            }
          }
        }
				return finalColor;
      }

    	void main(void) {
        vec4 finalColor = vec4(vColor.rgb, 1.0);

        if(vNormal != vec3(0.0, 0.0, 0.0))
        {
          /*finalColor = vec3(0.0, 0.0, 0.0);
          for(int i = 0; i < NB_LIGHTS; i++)
          {
            if(uLightToggled[i])
            {
              vec3 baseColor = vColor.rgb;
              vec3 L = normalize(vLightRay[i]);
              vec3 N = normalize(vNormal);

              float lambertTerm = dot(N,-L);
              if(lambertTerm > 0.0)
              {
                baseColor *= lambertTerm;
                finalColor += baseColor;
              }
            }
          }*/

          finalColor = vec4(phongShading(), 1.0);
        }
        gl_FragColor = finalColor;
      }
    </script>

    <script>
      // buffers
      var vertexBuffer = null;
      var indexBuffer = null;
      var colorBuffer = null;
      var normalBuffer = null;

      // scene geometry
      var indices = [];
      var vertices = [];
      var colors = [];
      var normals = [];

      // camera
      var mvMatrix = mat4.create();
      var pMatrix = mat4.create();
      var cameraPos = [4.0, -2.5, -6.0];

      // scene
      var solidShapes = [];
      var path = [];
      var drawPath = true;
      var lastTime = performance.now();
      var maxNumberOfSolidShapes = 100;
      var frameCount = 0;
      var elapsedTime = 0;

      // render
      const fieldOfView = degToRad(45);
      const zNear = 0.1;
      const zFar = 100.0;
      var aspect;

      // lights
      var lightsVerticesOffset = 0;
      var lightsColorsOffset = 0;
      var lightColorOn = {r: 1.0, g: 1.0, b: 0.0, a: 1.0};
      var lightColorOff = {r: 0.0, g: 0.0, b: 0.0, a: 1.0};

      var lightEmitColorOn = {r: 1.0, g: 1.0, b: 1.0};
      var lightEmitColorOff = {r: 0.0, g: 0.0, b: 0.0};

      var lightPositions = [];
      var lightToggled = [];

      function initShaderParameters(prg) {
        prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
        prg.vertexNormalAttribute   = glContext.getAttribLocation(prg, "aVertexNormal");
        prg.colorAttribute          = glContext.getAttribLocation(prg, "aColor");

        glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
        glContext.enableVertexAttribArray(prg.vertexNormalAttribute);
        glContext.enableVertexAttribArray(prg.colorAttribute);

        prg.pMatrixUniform  = glContext.getUniformLocation(prg, "uPMatrix");
        prg.mvMatrixUniform = glContext.getUniformLocation(prg, "uMVMatrix");
        prg.nUniform        = glContext.getUniformLocation(prg, "uNormalMatrix");
        prg.lightPositionsUniform = glContext.getUniformLocation(prg, "uLightPositions");
        prg.lightToggledUniform = glContext.getUniformLocation(prg, "uLightToggled");

        prg.lightAmbientUniform        = glContext.getUniformLocation(prg, 'uLightAmbient');
        prg.materialDiffuseUniform     = glContext.getUniformLocation(prg, 'uMaterialDiffuse');
        prg.materialSpecularUniform    = glContext.getUniformLocation(prg, 'uMaterialSpecular');
      }

      function initBuffers() {
        vertexBuffer  = getVertexBufferWithVertices(vertices);
        normalBuffer  = getVertexBufferWithVertices(normals);
        colorBuffer   = getVertexBufferWithVertices(colors);
        indexBuffer   = getIndexBufferWithIndices(indices);
      }

      function drawScene() {
        // for each solid shape, rotate and move it as long as its on the path
        for (let i=solidShapes.length-1; i>=0; i--) {
          // if (vec3.distance(vec3.fromValues(solidShapes[i].center.x, solidShapes[i].center.y, solidShapes[i].center.z),
          // vec3.fromValues(0,0,0)) > 7)
          //   removeElement(solidShapes[i], i);

          rotateElement(solidShapes[i], 1, true, true, true, false); // rotate 1 degree on each axis
          moveAlongPath(solidShapes[i], performance.now() - lastTime, i); // move elements along the Bézier curve
        }

        // update buffers
        if (solidShapes.length > 0) {
          vertexBuffer  = getVertexBufferWithVertices(vertices);
          normalBuffer  = getVertexBufferWithVertices(normals);
        }

        // draw fps
        drawFps();
        lastTime = performance.now();

        // init scene
        glContext.clearColor(0.2, 0.2, 0.2, 1.0);
        glContext.enable(glContext.DEPTH_TEST);
        glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
        glContext.viewport(0, 0, c_width, c_height);

        mat4.identity(pMatrix);
        mat4.identity(mvMatrix);

        // sets camera position / orientation
        mat4.rotate(mvMatrix, mvMatrix, degToRad(15), [1.0, 0.0, 0.0]);
        mat4.rotate(mvMatrix, mvMatrix, degToRad(35), [0.0, 1.0, 0.0]);
        mat4.translate(mvMatrix, mvMatrix, cameraPos);

        // sets the perspective
        mat4.perspective(pMatrix, fieldOfView, aspect, zNear, zFar);

        // send the camera matrices
        glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
        glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);

        // set the lights position
        glContext.uniform3fv(prg.lightPositionsUniform, lightPositions);
        // set the lights toggled
        glContext.uniform1iv(prg.lightToggledUniform, lightToggled);

        glContext.uniform3f(prg.materialSpecularUniform, 0.5, 0.0, 0.0);
        glContext.uniform3f(prg.materialDiffuseUniform, 0.9,0.0,0.0);
        glContext.uniform1f(prg.shininessUniform, 12.0);

        // normal matrix
        let normalMatrix = mat4.create();
        mat4.invert(normalMatrix, mvMatrix);
        normalMatrix = mat4.transpose(normalMatrix, normalMatrix);
        glContext.uniformMatrix4fv(prg.nUniform, false, normalMatrix);

        // buffers
        glContext.bindBuffer(glContext.ARRAY_BUFFER, normalBuffer);
        glContext.vertexAttribPointer(prg.vertexNormalAttribute, 3, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
        glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, colorBuffer);
        glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);

        // draw elements
        let numberLightsPoints = 4;
        if (drawPath) {
          glContext.drawElements(glContext.LINE_STRIP, path.length, glContext.UNSIGNED_SHORT, 0); // draw path
          glContext.drawElements(glContext.POINTS, numberLightsPoints, glContext.UNSIGNED_SHORT, path.length * 2); // draw lights
          glContext.drawElements(glContext.TRIANGLES, indices.length-path.length-numberLightsPoints, glContext.UNSIGNED_SHORT, (path.length) * 2 + numberLightsPoints * 2); // draw scene
        } else {
          glContext.drawElements(glContext.POINTS, numberLightsPoints, glContext.UNSIGNED_SHORT, 0); // draw lights
          glContext.drawElements(glContext.TRIANGLES, indices.length-numberLightsPoints, glContext.UNSIGNED_SHORT, numberLightsPoints * 2); // draw scene
        }
      }

      function initWebGL() {
        glContext = getGLContext("webgl-canvas");
        aspect = glContext.canvas.clientWidth / glContext.canvas.clientHeight;

        initProgram();
        initPath(35); // Initializes the path
        initStaticScene(); // Initializes the static scene
        initBuffers();
        renderLoop();
      }

      /**
      * Computes and draws FPS.
      */
      function drawFps() {
        frameCount++;
        elapsedTime += (performance.now() - lastTime);
        if(elapsedTime >= 1000) {
          fps = frameCount;
          frameCount = 0;
          elapsedTime -= 1000;

          document.getElementById("fps").innerHTML = fps + " fps";
        }
      }

      /**
      * Adds a new cube to the scene on the path's origin.
      */
      function addCube(width=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes) {
          solidShapes.push(new Cube(vertices, indices, colors, normals,
                                     width, {x: path[0][0], y: path[0][1], z: path[0][2]}, color
                                   ));
          initBuffers();
        } else
         console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Adds a new tetrahedron to the scene on the path's origin.
      */
      function addTetrahedron(width=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes) {
          solidShapes.push(new Tetrahedron(vertices, indices, colors, normals,
                                            width, {x: path[0][0], y: path[0][1], z: path[0][2]}, color
                                          ));
           initBuffers();
         } else
          console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Adds a new sphere to the scene on the path's origin.
      */
      function addSphere(width=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes) {
          solidShapes.push(new Sphere(vertices, indices, colors, normals,
                                        width, {x: path[0][0], y: path[0][1], z: path[0][2]}, color
                                      ));
           initBuffers();
         } else
          console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Moves the given solid shape to a new center.
      */
      function moveElement(solidShape, newCenter, updateBuffers=true) {
        solidShape.move(newCenter);
        if (updateBuffers)
          vertexBuffer = getVertexBufferWithVertices(vertices);
      }

      /**
      * Rotates the given solid shape of a given angle around the specified axis.
      */
      function rotateElement(solidShape, angle, xAxis=true, yAxis=true, zAxis=true, updateBuffers=true) {
        solidShape.rotate(angle, xAxis, yAxis, zAxis);
        if (updateBuffers) {
          vertexBuffer  = getVertexBufferWithVertices(vertices);
          normalBuffer  = getVertexBufferWithVertices(normals);
        }
      }

      /**
      * Removes the given solid shape (at given index in the solidShapes array) from the scene
      * and the solidShapes array. Updates the offsets of each remaining solid shape.
      */
      function removeElement(solidShape, index) {
        solidShape.delete(); // removes the shape's values from the shared arrays (vertices, indices, colors)
        for (let i=index+1; i<solidShapes.length; i++) // updates each remaining solid shape's offsets in shared arrays
          solidShapes[i].updateOffsets(solidShapes[index].numberVertices*3,
                                       solidShapes[index].numberIndices,
                                       solidShapes[index].numberVertices*4);
        solidShapes.splice(index, 1); // remove the solid shape from the solidShapes array
        initBuffers();
      }

      /**
      * Moves the given solid along the path.
      */
      function moveAlongPath(solidShape, dt, index) {
        let delta = solidShape.speed * dt / 1000; // computes the step for this iteration

        let dir = vec3.create();

        // retrieves the current position and creates the direction vector (destination - current pos)
        let currPos = vec3.fromValues(solidShape.center.x, solidShape.center.y, solidShape.center.z);
        vec3.sub(dir, path[solidShape.lastPathPoint+1], currPos);
        vec3.normalize(dir, dir); // normalize the direction
        vec3.scale(dir, dir, delta); // multiply the direction vector by the step

        let newPos = vec3.create();
        vec3.add(newPos, currPos, dir); // new position is the old one added to the movement vector

        // moves the solid shape to its new position
        moveElement(solidShape, {x: newPos[0], y: newPos[1], z: newPos[2]}, false);

        // if the distance between the current position and our goal is smaller than an error
        if (vec3.distance(currPos, path[solidShape.lastPathPoint+1]) < solidShape.positionComparaisonError) {
          solidShape.lastPathPoint++; // increment the path's control point id

          // move the solid shape to the path's control point (to avoid accumulating errors)
          moveElement(solidShape, {x: path[solidShape.lastPathPoint][0], y: path[solidShape.lastPathPoint][1], z: path[solidShape.lastPathPoint][2]});

          // if the last path's control point has been reached
          if (solidShape.lastPathPoint >= path.length-1)
            removeElement(solidShape, index); // remove the solid shape
        }
      }

      /**
      * Changes the given light's position.
      */
      function changeLightPos(lightNumber, newPos) {
        vertices[lightsVerticesOffset + lightNumber * 3 + 1] = newPos;
        vertexBuffer  = getVertexBufferWithVertices(vertices);

        lightPositions[lightNumber * 3 + 1] = newPos;
      }

      /**
      * Toggles on and off the given light's id.
      */
      function toggleLight(lightNumber) {
        let offset = lightsColorsOffset + (lightNumber * 4);
        let isOn = colors[offset + 0] == lightColorOn.r &&
                   colors[offset + 1] == lightColorOn.g &&
                   colors[offset + 2] == lightColorOn.b &&
                   colors[offset + 3] == lightColorOn.a;
        colors[offset + 0] = isOn ? lightColorOff.r : lightColorOn.r;
        colors[offset + 1] = isOn ? lightColorOff.g : lightColorOn.g;
        colors[offset + 2] = isOn ? lightColorOff.b : lightColorOn.b;
        colors[offset + 3] = isOn ? lightColorOff.a : lightColorOn.a;
        colorBuffer   = getVertexBufferWithVertices(colors);

        if(lightToggled[lightNumber] == 0)
          lightToggled[lightNumber] = 1;
        else
          lightToggled[lightNumber] = 0;
      }

      /**
      * Initializes the static objects on the scene.
      */
      function initStaticScene() {
        let groundCenter = {x: 0.0, y: 0.0, z: 0.0};
        let groundSize = {width: 5.0, depth: 5.0};

        initSceneLights(groundCenter, groundSize);

        let indicesOffset = indices.length;
        // ground
        vertices.push(groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2, // P0
                      groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P1
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P2
                      groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2, // P0
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P2
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2  // P3
                    );
        indices.push(indicesOffset+0, indicesOffset+1, indicesOffset+2,
                     indicesOffset+3, indicesOffset+4, indicesOffset+5);
        colors.push(0.6, 0.6, 0.6, 1.0, // P0
                    0.6, 0.6, 0.6, 1.0, // P1
                    0.6, 0.6, 0.6, 1.0, // P2
                    0.6, 0.6, 0.6, 1.0, // P3
                    0.6, 0.6, 0.6, 1.0, // P4
                    0.6, 0.6, 0.6, 1.0  // P5
                  );
        normals.push(0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0);

        // walls
        // let wallHeight = 5.0;
        // vertices.push(groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2,
        //               groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2,
        //               groundCenter.x + groundSize.width/2, groundCenter.y + wallHeight, groundCenter.z + groundSize.depth/2,
        //               groundCenter.x + groundSize.width/2, groundCenter.y + wallHeight, groundCenter.z - groundSize.depth/2,
        //               groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2,
        //               groundCenter.x - groundSize.width/2, groundCenter.y + wallHeight, groundCenter.z - groundSize.depth/2);
        // indices.push(indicesOffset+4, indicesOffset+5, indicesOffset+6,
        //              indicesOffset+4, indicesOffset+6, indicesOffset+7,
        //              indicesOffset+8, indicesOffset+4, indicesOffset+7,
        //              indicesOffset+8, indicesOffset+7, indicesOffset+9);
        // colors.push(0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0);
        // normals.push(0.0, 0.0, 0.0, 0.0,
        //              0.0, 0.0, 0.0, 0.0,
        //              0.0, 0.0, 0.0, 0.0,
        //              0.0, 0.0, 0.0, 0.0);
      }

      /**
      * Initializes the static lights objects on the scene.
      */
      function initSceneLights(groundCenter, groundSize) {
        lightsVerticesOffset = vertices.length;
        lightsColorsOffset = colors.length;
        let indicesOffset = indices.length;
        vertices.push(groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2, // P0
                      groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P1
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P2
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2  // P3
                    );
        lightPositions.push(groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2, // P0
                      groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P1
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P2
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2  // P3
                      );
        lightToggled.push(1,1,1,1);


        indices.push(indicesOffset+0, indicesOffset+1, indicesOffset+2, indicesOffset+3);
        colors.push(1.0, 1.0, 0.0, 1.0, // P0
                    1.0, 1.0, 0.0, 1.0, // P1
                    1.0, 1.0, 0.0, 1.0, // P2
                    1.0, 1.0, 0.0, 1.0  // P3
                  );
        normals.push(0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0
                   );
      }

      /**
      * Initializes the path (Bézier curve) which will be followed by the solid shapes.
      */
      function initPath(numberIterations) {
        // set control points (first is origin and last is goal)
        let controlPoints = [vec3.fromValues( 4.9, 0.1, -4.9),
                             vec3.fromValues( 0.0, 0.2, -4.9),
                             vec3.fromValues(-4.9, 0.5, -4.9),
                             vec3.fromValues(-4.9, 1.4,  0.0),
                             vec3.fromValues(-4.9, 1.5,  6.9),
                             vec3.fromValues( 0.0, 1.6,  4.9),
                             vec3.fromValues( 4.9, 1.7,  4.9),
                             vec3.fromValues( 4.9, 1.7,  0.0),
                             vec3.fromValues( 4.9, 2.1, -4.9),
                             vec3.fromValues( 0.0, 2.3, -4.9),
                             vec3.fromValues(-4.9, 2.5, -4.9),
                             vec3.fromValues(-2.9, 2.7,  0.0),
                             vec3.fromValues(-2.9, 3.4,  1.5)] ;

        const inc = 1/numberIterations; // sets the delta for the Bézier curve

        for (let t=0; t<1; t+=inc) // computes cuve points
          CastelJau(t, controlPoints, controlPoints.length);
        path.reverse();

        // adds points to webgl arrays
        if (drawPath) {
          for (let i=0; i<path.length; i++) {
            vertices.push(path[i][0], path[i][1], path[i][2]);
            indices.push(i);
            colors.push(1.0, 0.0, 0.5, 0.2);
            normals.push(0.0, 0.0, 0.0);
          }
        }
      }

      /**
      * Castlejau implementation adapted from : http://fvirtman.free.fr/recueil/02_03_09_bezier.c.php
      * Used to create a Bézier curve with given control points.
      */
      function CastelJau(t, controlPoints, nbPoints) {
        let subtab = [];
        if (nbPoints == 1) {
          path.push(controlPoints[0]);
          return;
        }
        for (let i=0; i<nbPoints-1; i++)
          subtab.push(vec3.fromValues(t * controlPoints[i][0] + (1-t) * controlPoints[i+1][0],
                                      t * controlPoints[i][1] + (1-t) * controlPoints[i+1][1],
                                      t * controlPoints[i][2] + (1-t) * controlPoints[i+1][2]));
        CastelJau(t, subtab, nbPoints-1);
      }
    </script>

    <style>
      .light-div{
        padding: 5px;
        border: 1px solid #CCC;
        border-radius: 4px;
        vertical-align: middle;
        margin-bottom: 10px;
        width: 350px;
      }

      .title{
        line-height: 25px;
        font-weight: bold;
      }

      .label{
        line-height: 25px;
        margin-left: 25px;
      }
    </style>

  </head>
  <body onload="initWebGL()">
    <header>
        <h1>&nbsp;Infographie, Labo 2 - ...<br></h1>
        <br>&nbsp;&nbsp;Équipe 6 : Chacun Guillaume, Graells Noah, Herbelin Ludovic<br>
        <br>&nbsp;&nbsp;rendu le 27.11.18
    </header>
    <p>
      Le but du laboratoire était de ...
    </p>
    <canvas id="webgl-canvas" width="800" height="600">
      HTML5 is not supported
    </canvas>
    <div id="fps"></div>

    <div id="control-panel">
      <div class="user-input">
        <h1>Ajout de forme</h1><br/>
        <input type="button" value="Ajouter un cube" onclick="addCube(0.4, {r: 1.0, g: 0.0, b: 0.0, a: 0.8})" style="font-size:15px; width: 100px; height: 65px; white-space: normal;"/>
        <input type="button" value="Ajouter un tétraèdre" onclick="addTetrahedron(0.4, {r: 0.0, g: 1.0, b: 0.0, a: 0.8})" style="font-size:15px; width:100px; height: 65px; white-space: normal;" />

        <br/>
        <br/><h1>Gestion de la lumière</h1><br/>

        <div class="light-div">
          <input type="checkbox" checked onchange="toggleLight(0)" /> <span class="title">Spot premier plan</span> <br>
          <span class="label">Position en Y : </span><input style="float: right; width:50%" type="range" min="0" max="3" value ="0" step="0.1" onchange="changeLightPos(0, this.value)" oninput="changeLightPos(0, this.value)"/>
        </div>

        <div class="light-div">
          <input type="checkbox" checked onchange="toggleLight(1)" /> <span class="title">Spot de gauche</span> <br>
          <span class="label">Position en Y : </span><input style="float: right; width:50%" type="range" min="0" max="3" value ="0" step="0.1" onchange="changeLightPos(1, this.value)" oninput="changeLightPos(1, this.value)"/>
        </div>

        <div class="light-div">
          <input type="checkbox" checked onchange="toggleLight(2)" /> <span class="title">Spot arrière plan</span> <br>
          <span class="label" >Position en Y : </span><input style="float: right; width:50%" type="range" min="0" max="3" value ="0" step="0.1" onchange="changeLightPos(2, this.value)" oninput="changeLightPos(2, this.value)"/>
        </div>

        <div class="light-div">
          <input type="checkbox" checked onchange="toggleLight(3)" /> <span class="title">Spot de droite</span> <br>
          <span class="label" >Position en Y : </span><input style="float: right; width:50%" type="range" min="0" max="3" value ="0" step="0.1" onchange="changeLightPos(3, this.value)" oninput="changeLightPos(3, this.value)"/>
        </div>

      </div>
    </div>
  </body>
</html>
