<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="./css/stylesheet.css">
    <script src="./js/commonFunctions.js"></script>
    <script src="./js/gl-matrix-min.js"></script>
    <script src="./js/webglTools.js"></script>

    <script src="./SolidShape.js"></script>
    <script src="./Cube.js"></script>
    <script src="./Tetrahedron.js"></script>
    <script src="./Sphere.js"></script>

    <!-- Vertex Shader -->
    <script id="shader-vs" type="x-shader/x-vertex">
      #define NB_LIGHTS 4

      attribute vec3 aVertexPosition;
      attribute vec3 aVertexNormal;
      attribute vec4 aColor;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      uniform mat4 uNormalMatrix;
      uniform vec3 uViewPos;

      varying vec4 vColor;
      varying vec3 vNormal;
      varying vec3 vFragPos;
      varying vec3 vViewPos;


    	void main(void) {
        gl_PointSize = 15.0;
        vColor = aColor;
        vViewPos = uViewPos;
        vFragPos = aVertexPosition;

        vec4 vertex = uMVMatrix * vec4(aVertexPosition, 1.0);
        if (aVertexNormal != vec3(0.0,0.0,0.0)) {
          vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));
        } else {
          vNormal = vec3(0.0, 0.0, 0.0);
        }
        gl_Position = uPMatrix * vertex;
  	  }
    </script>

    <!-- Fragment Shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
      #ifdef GL_ES
    		precision highp float;
      #endif
      #define NB_LIGHTS 4

      varying vec3 vNormal;
      varying vec4 vColor;
      varying vec3 vFragPos;
      varying vec3 vViewPos;

      uniform int uLightToggled[NB_LIGHTS];
      uniform vec3 uLightPositions[NB_LIGHTS];

      vec3 CalcPointLight(vec3 lightPos, vec3 normal, vec3 fragPos, vec3 viewDir, vec4 defaultColor) {
        vec3 lightDir = normalize(lightPos - fragPos);

        // diffuse shading
        float diff = max(dot(normal, lightDir), 0.0);

        // specular shading
        vec3 reflectDir = reflect(-lightDir, normal);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);

        // attenuation
        float distance    = length(lightPos - fragPos);
        float attenuation = 1.0;// / (1.0 + 0.09 * distance + 0.032 * (distance * distance));

        // combine results
        //defaultColor  = vec4(1.0, 1.0, 1.0, 1.0); // tmp
        vec3 ambient  = vec3(0.05, 0.05, 0.05) * defaultColor.rgb;
        vec3 diffuse  = vec3(0.8, 0.8, 0.8) * diff * defaultColor.rgb;
        vec3 specular = vec3(1.0, 1.0, 1.0) * spec * defaultColor.rgb;

        ambient  *= attenuation;
        diffuse  *= attenuation;
        specular *= attenuation;

        return (ambient + diffuse + specular);
      }

      void main(void) {
        vec4 defaultColor = vec4(vColor.rgb, 1.0);

        vec3 norm = normalize(vNormal);
        vec3 viewDir = normalize(vViewPos - vFragPos);
        vec3 result = vec3(0.0, 0.0, 0.0);

        // if this isn't part of the curve
        if(vNormal != vec3(0.0, 0.0, 0.0)) {
          // compute the sub-color value for each enabled light
          for(int i=0; i<NB_LIGHTS; i++) {
            if (uLightToggled[i] == 1) {
              //vec3 lightPos = vec3(0.0, 1.0, 0.0);
              vec3 lightPos = uLightPositions[i];
              result += CalcPointLight(lightPos, norm, vFragPos, viewDir, defaultColor);
            }
          }

          gl_FragColor = vec4(result, 1.0);
        } else {
          gl_FragColor = defaultColor;
        }
      }
    </script>

    <script>
      // buffers
      var vertexBuffer = null;
      var indexBuffer = null;
      var colorBuffer = null;
      var normalBuffer = null;

      // scene geometry
      var indices = [];
      var vertices = [];
      var colors = [];
      var normals = [];

      // camera
      var mvMatrix = mat4.create();
      var pMatrix = mat4.create();
      var cameraPos = [4.0, -2.5, -6.0]; // 0.0, -1.25, -7.0

      // scene
      var solidShapes = [];
      var path = [];
      var drawPath = true;
      var lastTime = performance.now();
      var maxNumberOfSolidShapes = 100;
      var frameCount = 0;
      var elapsedTime = 0;

      // render
      const fieldOfView = degToRad(45);
      const zNear = 0.1;
      const zFar = 100.0;
      var aspect;

      // lights
      var lightsVerticesOffset = 0;
      var lightsColorsOffset = 0;
      var lightColorOn = {r: 1.0, g: 1.0, b: 0.0, a: 1.0};
      var lightColorOff = {r: 0.0, g: 0.0, b: 0.0, a: 1.0};

      var lightEmitColorOn = {r: 0.1, g: 0.1, b: 0.1};
      var lightEmitColorOff = {r: 0.0, g: 0.0, b: 0.0};

      var lightPositions = [];
      var lightToggled = [];

      var minLightHeight = 0.3;
      var maxLightHeight = 3.5;

      function initShaderParameters(prg) {
        prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
        prg.vertexNormalAttribute   = glContext.getAttribLocation(prg, "aVertexNormal");
        prg.colorAttribute          = glContext.getAttribLocation(prg, "aColor");

        glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
        glContext.enableVertexAttribArray(prg.vertexNormalAttribute);
        glContext.enableVertexAttribArray(prg.colorAttribute);

        prg.pMatrixUniform        = glContext.getUniformLocation(prg, "uPMatrix");
        prg.mvMatrixUniform       = glContext.getUniformLocation(prg, "uMVMatrix");
        prg.nUniform              = glContext.getUniformLocation(prg, "uNormalMatrix");
        prg.lightPositionsUniform = glContext.getUniformLocation(prg, "uLightPositions");
        prg.lightToggledUniform   = glContext.getUniformLocation(prg, "uLightToggled");
        prg.viewPosUniform        = glContext.getUniformLocation(prg, "uViewPos");
      }

      function initBuffers() {
        vertexBuffer  = getVertexBufferWithVertices(vertices);
        normalBuffer  = getVertexBufferWithVertices(normals);
        colorBuffer   = getVertexBufferWithVertices(colors);
        indexBuffer   = getIndexBufferWithIndices(indices);
      }

      function drawScene() {
        // for each solid shape, rotate and move it as long as its on the path
        for (let i=solidShapes.length-1; i>=0; i--) {
          // if (vec3.distance(vec3.fromValues(solidShapes[i].center.x, solidShapes[i].center.y, solidShapes[i].center.z),
          // vec3.fromValues(0,0,0)) > 7)
          //   removeElement(solidShapes[i], i);

          rotateElement(solidShapes[i], 0.3, true, true, true, false); // rotate 1 degree on each axis
          moveAlongPath(solidShapes[i], performance.now() - lastTime, i); // move elements along the Bézier curve
        }

        // update buffers
        if (solidShapes.length > 0) {
          vertexBuffer  = getVertexBufferWithVertices(vertices);
          normalBuffer  = getVertexBufferWithVertices(normals);
        }

        // draw fps
        drawFps();
        lastTime = performance.now();

        // init scene
        glContext.clearColor(0.15, 0.15, 0.15, 1.0);
        glContext.enable(glContext.DEPTH_TEST);
        glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
        glContext.viewport(0, 0, c_width, c_height);

        mat4.identity(pMatrix);
        mat4.identity(mvMatrix);

        // sets camera position / orientation
        mat4.rotate(mvMatrix, mvMatrix, degToRad(15), [1.0, 0.0, 0.0]);
        mat4.rotate(mvMatrix, mvMatrix, degToRad(35), [0.0, 1.0, 0.0]);
        mat4.translate(mvMatrix, mvMatrix, cameraPos);

        // sets the perspective
        mat4.perspective(pMatrix, fieldOfView, aspect, zNear, zFar);

        // send the camera matrices
        glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
        glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);

        // send the lights position
        glContext.uniform3fv(prg.lightPositionsUniform, lightPositions);

        // send the lights state
        glContext.uniform1iv(prg.lightToggledUniform, lightToggled);

        // send the camera's position
        glContext.uniform3f(prg.viewPosUniform, cameraPos[0], cameraPos[1], cameraPos[2]);

        // normal matrix
        let normalMatrix = mat4.create();
        mat4.invert(normalMatrix, mvMatrix);
        normalMatrix = mat4.transpose(normalMatrix, normalMatrix);
        glContext.uniformMatrix4fv(prg.nUniform, false, normalMatrix);

        // buffers
        glContext.bindBuffer(glContext.ARRAY_BUFFER, normalBuffer);
        glContext.vertexAttribPointer(prg.vertexNormalAttribute, 3, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
        glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, colorBuffer);
        glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);

        // draw elements
        let numberLightsPoints = 4;
        if (drawPath) {
          glContext.drawElements(glContext.LINE_STRIP, path.length, glContext.UNSIGNED_SHORT, 0); // draw path
          glContext.drawElements(glContext.POINTS, numberLightsPoints, glContext.UNSIGNED_SHORT, path.length * 2); // draw lights
          glContext.drawElements(glContext.TRIANGLES, indices.length-path.length-numberLightsPoints, glContext.UNSIGNED_SHORT, (path.length) * 2 + numberLightsPoints * 2); // draw scene
        } else {
          glContext.drawElements(glContext.POINTS, numberLightsPoints, glContext.UNSIGNED_SHORT, 0); // draw lights
          glContext.drawElements(glContext.TRIANGLES, indices.length-numberLightsPoints, glContext.UNSIGNED_SHORT, numberLightsPoints * 2); // draw scene
        }
      }

      function initWebGL() {
        glContext = getGLContext("webgl-canvas");
        aspect = glContext.canvas.clientWidth / glContext.canvas.clientHeight;
        initProgram();

        initPath(35); // Initializes the path
        initStaticScene(); // Initializes the static scene
        initLightsSliders();

        initBuffers();
        renderLoop();
      }

      /**
      * Computes and draws FPS.
      */
      function drawFps() {
        frameCount++;
        elapsedTime += (performance.now() - lastTime);
        if(elapsedTime >= 1000) {
          fps = frameCount;
          frameCount = 0;
          elapsedTime -= 1000;

          document.getElementById("fps").innerHTML = fps + " fps";
        }
      }

      /**
      * Adds a new cube to the scene on the path's origin.
      */
      function addCube(width=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes) {
          solidShapes.push(new Cube(vertices, indices, colors, normals,
                                     width, {x: path[0][0], y: path[0][1], z: path[0][2]}, color
                                   ));
          initBuffers();
        } else
         console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Adds a new tetrahedron to the scene on the path's origin.
      */
      function addTetrahedron(width=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes) {
          solidShapes.push(new Tetrahedron(vertices, indices, colors, normals,
                                            width, {x: path[0][0], y: path[0][1], z: path[0][2]}, color
                                          ));
           initBuffers();
         } else
          console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Adds a new sphere to the scene on the path's origin.
      */
      function addSphere(width=0.5, color={r:1.0, g:1.0, b:1.0, a:1.0}) {
        if (solidShapes.length < maxNumberOfSolidShapes) {
          solidShapes.push(new Sphere(vertices, indices, colors, normals,
                                        width, {x: path[0][0], y: path[0][1], z: path[0][2]}, color
                                      ));
           initBuffers();
         } else
          console.log("You can add at most " + maxNumberOfSolidShapes + " elements to the scene.");
      }

      /**
      * Moves the given solid shape to a new center.
      */
      function moveElement(solidShape, newCenter, updateBuffers=true) {
        solidShape.move(newCenter);
        if (updateBuffers)
          vertexBuffer = getVertexBufferWithVertices(vertices);
      }

      /**
      * Rotates the given solid shape of a given angle around the specified axis.
      */
      function rotateElement(solidShape, angle, xAxis=true, yAxis=true, zAxis=true, updateBuffers=true) {
        solidShape.rotate(angle, xAxis, yAxis, zAxis);
        if (updateBuffers) {
          vertexBuffer  = getVertexBufferWithVertices(vertices);
          normalBuffer  = getVertexBufferWithVertices(normals);
        }
      }

      /**
      * Removes the given solid shape (at given index in the solidShapes array) from the scene
      * and the solidShapes array. Updates the offsets of each remaining solid shape.
      */
      function removeElement(solidShape, index) {
        solidShape.delete(); // removes the shape's values from the shared arrays (vertices, indices, colors)
        for (let i=index+1; i<solidShapes.length; i++) // updates each remaining solid shape's offsets in shared arrays
          solidShapes[i].updateOffsets(solidShapes[index].numberVertices*3,
                                       solidShapes[index].numberIndices,
                                       solidShapes[index].numberVertices*4);
        solidShapes.splice(index, 1); // remove the solid shape from the solidShapes array
        initBuffers();
      }

      /**
      * Moves the given solid along the path.
      */
      function moveAlongPath(solidShape, dt, index) {
        let delta = solidShape.speed * dt / 1000; // computes the step for this iteration

        let dir = vec3.create();

        // retrieves the current position and creates the direction vector (destination - current pos)
        let currPos = vec3.fromValues(solidShape.center.x, solidShape.center.y, solidShape.center.z);
        vec3.sub(dir, path[solidShape.lastPathPoint+1], currPos);
        vec3.normalize(dir, dir); // normalize the direction
        vec3.scale(dir, dir, delta); // multiply the direction vector by the step

        let newPos = vec3.create();
        vec3.add(newPos, currPos, dir); // new position is the old one added to the movement vector

        // moves the solid shape to its new position
        moveElement(solidShape, {x: newPos[0], y: newPos[1], z: newPos[2]}, false);

        // if the distance between the current position and our goal is smaller than an error
        if (vec3.distance(currPos, path[solidShape.lastPathPoint+1]) < solidShape.positionComparaisonError) {
          solidShape.lastPathPoint++; // increment the path's control point id

          // move the solid shape to the path's control point (to avoid accumulating errors)
          moveElement(solidShape, {x: path[solidShape.lastPathPoint][0], y: path[solidShape.lastPathPoint][1], z: path[solidShape.lastPathPoint][2]});

          // if the last path's control point has been reached
          if (solidShape.lastPathPoint >= path.length-1)
            removeElement(solidShape, index); // remove the solid shape
        }
      }

      /**
      * Changes the given light's position.
      */
      function changeLightPos(lightNumber, newPos) {
        vertices[lightsVerticesOffset + lightNumber * 3 + 1] = parseFloat(newPos);
        vertexBuffer = getVertexBufferWithVertices(vertices);

        lightPositions[lightNumber * 3 + 1] = parseFloat(newPos);
      }

      /**
      * Toggles on and off the given light's id.
      */
      function toggleLight(lightNumber) {
        let offset = lightsColorsOffset + (lightNumber * 4);

        // change light's color
        colors[offset + 0] = lightToggled[lightNumber] == 1 ? lightColorOff.r : lightColorOn.r;
        colors[offset + 1] = lightToggled[lightNumber] == 1 ? lightColorOff.g : lightColorOn.g;
        colors[offset + 2] = lightToggled[lightNumber] == 1 ? lightColorOff.b : lightColorOn.b;
        colors[offset + 3] = lightToggled[lightNumber] == 1 ? lightColorOff.a : lightColorOn.a;
        colorBuffer = getVertexBufferWithVertices(colors);

        // toggle light's state
        lightToggled[lightNumber] = lightToggled[lightNumber] == 0 ? 1 : 0;
      }

      /**
      * Toggles on and off the each scene's light.
      */
      function toggleAllLights() {
        for (let i=0; i<4; i++) {
          toggleLight(i);
          document.getElementById("toggleLight" + (i+1)).checked = lightToggled[i] == 1;
        }
      }

      /**
      * Resets each scene's light position.
      */
      function resetLightsPosition() {
        for (let i=0; i<4; i++) {
          changeLightPos(i, 0);
          document.getElementById("light" + (i+1) + "Position").value = 0;
        }
      }

      /**
      * Initializes the static objects on the scene.
      */
      function initStaticScene() {
        let groundCenter = {x: 0.0, y: 0.0, z: 0.0};
        let groundSize = {width: 5.0, depth: 5.0};

        initSceneLights(groundCenter, groundSize);

        let indicesOffset = indices.length;
        // ground
        vertices.push(groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2, // P0
                      groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P1
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P2
                      groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2, // P0
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2, // P2
                      groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2  // P3
                    );
        indices.push(indicesOffset+0, indicesOffset+1, indicesOffset+2,
                     indicesOffset+3, indicesOffset+4, indicesOffset+5);
        colors.push(0.6, 0.6, 0.6, 1.0, // P0
                    0.6, 0.6, 0.6, 1.0, // P1
                    0.6, 0.6, 0.6, 1.0, // P2
                    0.6, 0.6, 0.6, 1.0, // P3
                    0.6, 0.6, 0.6, 1.0, // P4
                    0.6, 0.6, 0.6, 1.0  // P5
                  );
        normals.push(0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 1.0, 0.0);

        // walls
        // let wallHeight = 5.0;
        // vertices.push(groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2,
        //               groundCenter.x + groundSize.width/2, groundCenter.y, groundCenter.z + groundSize.depth/2,
        //               groundCenter.x + groundSize.width/2, groundCenter.y + wallHeight, groundCenter.z + groundSize.depth/2,
        //               groundCenter.x + groundSize.width/2, groundCenter.y + wallHeight, groundCenter.z - groundSize.depth/2,
        //               groundCenter.x - groundSize.width/2, groundCenter.y, groundCenter.z - groundSize.depth/2,
        //               groundCenter.x - groundSize.width/2, groundCenter.y + wallHeight, groundCenter.z - groundSize.depth/2);
        // indices.push(indicesOffset+4, indicesOffset+5, indicesOffset+6,
        //              indicesOffset+4, indicesOffset+6, indicesOffset+7,
        //              indicesOffset+8, indicesOffset+4, indicesOffset+7,
        //              indicesOffset+8, indicesOffset+7, indicesOffset+9);
        // colors.push(0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0,
        //             0.6, 0.4, 0.4, 1.0);
        // normals.push(0.0, 0.0, 0.0, 0.0,
        //              0.0, 0.0, 0.0, 0.0,
        //              0.0, 0.0, 0.0, 0.0,
        //              0.0, 0.0, 0.0, 0.0);
      }

      /**
      * Initializes the static lights objects on the scene.
      */
      function initSceneLights(groundCenter, groundSize) {
        lightsVerticesOffset = vertices.length;
        lightsColorsOffset = colors.length;
        let indicesOffset = indices.length;
        vertices.push(groundCenter.x - groundSize.width/2, minLightHeight, groundCenter.z + groundSize.depth/2, // P0
                      groundCenter.x - groundSize.width/2, minLightHeight, groundCenter.z - groundSize.depth/2, // P1
                      groundCenter.x + groundSize.width/2, minLightHeight, groundCenter.z - groundSize.depth/2, // P2
                      groundCenter.x + groundSize.width/2, minLightHeight, groundCenter.z + groundSize.depth/2  // P3
                    );
        lightPositions.push(groundCenter.x - groundSize.width/2, minLightHeight, groundCenter.z + groundSize.depth/2, // P0
                            groundCenter.x - groundSize.width/2, minLightHeight, groundCenter.z - groundSize.depth/2, // P1
                            groundCenter.x + groundSize.width/2, minLightHeight, groundCenter.z - groundSize.depth/2, // P2
                            groundCenter.x + groundSize.width/2, minLightHeight, groundCenter.z + groundSize.depth/2  // P3
                          );
        lightToggled.push(1,1,1,1);


        indices.push(indicesOffset+0, indicesOffset+1, indicesOffset+2, indicesOffset+3);
        colors.push(1.0, 1.0, 0.0, 1.0, // P0
                    1.0, 1.0, 0.0, 1.0, // P1
                    1.0, 1.0, 0.0, 1.0, // P2
                    1.0, 1.0, 0.0, 1.0  // P3
                  );
        normals.push(0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                     0.0, 0.0, 0.0
                   );
      }

      /**
      * Initializes the path (Bézier curve) which will be followed by the solid shapes.
      */
      function initPath(numberIterations) {
        // set control points (first is origin and last is goal)
        let controlPoints = [vec3.fromValues( 4.9, 0.1, -4.9),
                             vec3.fromValues( 0.0, 0.2, -4.9),
                             vec3.fromValues(-4.9, 0.5, -4.9),
                             vec3.fromValues(-4.9, 1.4,  0.0),
                             vec3.fromValues(-4.9, 1.5,  6.9),
                             vec3.fromValues( 0.0, 1.6,  4.9),
                             vec3.fromValues( 4.9, 1.7,  4.9),
                             vec3.fromValues( 4.9, 1.7,  0.0),
                             vec3.fromValues( 4.9, 2.1, -4.9),
                             vec3.fromValues( 0.0, 2.3, -4.9),
                             vec3.fromValues(-4.9, 2.5, -4.9),
                             vec3.fromValues(-2.9, 2.7,  0.0),
                             vec3.fromValues(-2.9, 3.4,  1.5)] ;

        const inc = 1/numberIterations; // sets the delta for the Bézier curve

        for (let t=0; t<1; t+=inc) // computes cuve points
          castelJau(t, controlPoints, controlPoints.length);
        path.reverse();

        // adds points to webgl arrays
        if (drawPath) {
          for (let i=0; i<path.length; i++) {
            vertices.push(path[i][0], path[i][1], path[i][2]);
            indices.push(i);
            colors.push(1.0, 0.0, 0.5, 0.2);
            normals.push(0.0, 0.0, 0.0);
          }
        }
      }

      /**
      * Castlejau implementation adapted from : http://fvirtman.free.fr/recueil/02_03_09_bezier.c.php
      * Used to create a Bézier curve with given control points.
      */
      function castelJau(t, controlPoints, nbPoints) {
        let subtab = [];
        if (nbPoints == 1) {
          path.push(controlPoints[0]);
          return;
        }
        for (let i=0; i<nbPoints-1; i++)
          subtab.push(vec3.fromValues(t * controlPoints[i][0] + (1-t) * controlPoints[i+1][0],
                                      t * controlPoints[i][1] + (1-t) * controlPoints[i+1][1],
                                      t * controlPoints[i][2] + (1-t) * controlPoints[i+1][2]));
        castelJau(t, subtab, nbPoints-1);
      }
    
      /**
      * Initializes lights slides min, max and value.
      */
      function initLightsSliders() {
        for (let i=0; i<4; i++) {
          document.getElementById("light" + (i+1) + "Position").min = minLightHeight.toString();
          document.getElementById("light" + (i+1) + "Position").max = maxLightHeight.toString();
          document.getElementById("light" + (i+1) + "Position").value = lightPositions[(i*3)+1].toString();
        }
      }
    </script>

    <style>
      .light-div{
        padding: 5px;
        border: 1px solid #CCC;
        border-radius: 4px;
        vertical-align: middle;
        margin-bottom: 10px;
        width: 350px;
      }

      .title{
        line-height: 25px;
        font-weight: bold;
      }

      .label{
        line-height: 25px;
        margin-left: 25px;
      }
    </style>

  </head>
  <body onload="initWebGL()">
    <header>
        <h1>&nbsp;Infographie, Labo 2 - Animation de formes sur courbes de Bézier et éclairage<br></h1>
        <br>&nbsp;&nbsp;Équipe 6 : Chacun Guillaume, Graells Noah, Herbelin Ludovic<br>
        <br>&nbsp;&nbsp;rendu le 04.12.18
    </header>
    <p>
      Le but du laboratoire était de déplacer des formes sur des courbes de Bézier avec de l'éclairage. <br />
      Nous avons choisi de placer 4 lumières sur la scène et de laisser l'utilisateur les allumer et éteindre et les déplacer en hauteur. <br />

      Le code est séparé en plusieurs classes de formes, cela nous permet d'avoir un code plus séparé et d'instancier des formes facilement. <br />
      Nous pourrions également rajouter d'autres types de formes relativement facilement sans toucher à la structure du code lié à WebGL. <br />
      Nous avons choisi de travailler en mode de dessin "TRIANGLES" avec les mêmes buffers pour toutes les formes, nous pouvons ainsi dessiner toutes les formes d'un coup et profiter de la puissance parallèle des GPU. <br />
      
      <br/>
      <h2>todo :</h2>
      - corriger le problème de style des boutons<br/>
      - corriger le shading de phong<br/>
      - écrire la "doc" :<br/>
        - expliquer le problème de lag avec les sphères<br/>
        - expliquer pourquoi on a fait ces classes (séparation du code, pour dessiner toutes les formes d'un coup et profiter de la parallélisation effectuée par le GPU -> au lieu de dessiner les formes une par une)<br/>
    </p>
    <canvas id="webgl-canvas" width="800" height="600">
      HTML5 is not supported
    </canvas>
    <div id="fps"></div>

    <div id="control-panel">
      <div class="user-input">
        <h1>Ajout de formes</h1><br/>
        <input type="button" value="Ajouter un cube" onclick="addCube(0.4, {r: 1.0, g: 0.0, b: 0.0, a: 0.8})" style="font-size:15px; width: 100px; height: 65px; white-space: normal;"/>
        <input type="button" value="Ajouter un tétraèdre" onclick="addTetrahedron(0.4, {r: 0.0, g: 1.0, b: 0.0, a: 0.8})" style="font-size:15px; width:100px; height: 65px; white-space: normal;" />
        <input type="button" value="Ajouter une sphère" onclick="addSphere(0.3, {r: 0.0, g: 1.0, b: 1.0, a: 0.8})" style="font-size:15px; width:100px; height: 65px; white-space: normal;" />

        <br/>
        <br/><h1>Gestion de la lumière</h1><br/>

        <div class="light-div">
          <input type="checkbox" checked onchange="toggleLight(0)" id="toggleLight1" />
          <span class="title"><label for="toggleLight1">Spot premier plan</label></span> <br>
          <span class="label">Position en Y : </span><input style="float: right; width:50%" type="range" step="0.1" id="light1Position" onchange="changeLightPos(0, this.value)" oninput="changeLightPos(0, this.value)"/>
        </div>

        <div class="light-div">
          <input type="checkbox" checked onchange="toggleLight(1)" id="toggleLight2" />
          <span class="title"><label for="toggleLight2">Spot de gauche</label></span> <br>
          <span class="label">Position en Y : </span><input style="float: right; width:50%" type="range" min=minLightHeight.toString() max=maxLightHeight.toString() value=lightPositions[1+1].toString() step="0.1" id="light2Position" onchange="changeLightPos(1, this.value)" oninput="changeLightPos(1, this.value)"/>
        </div>

        <div class="light-div">
          <input type="checkbox" checked onchange="toggleLight(2)" id="toggleLight3" />
          <span class="title"><label for="toggleLight3">Spot arrière p</label>lan</span> <br>
          <span class="label" >Position en Y : </span><input style="float: right; width:50%" type="range" min=minLightHeight.toString() max=maxLightHeight.toString() value=lightPositions[2+1].toString() step="0.1" id="light3Position" onchange="changeLightPos(2, this.value)" oninput="changeLightPos(2, this.value)"/>
        </div>

        <div class="light-div">
          <input type="checkbox" checked onchange="toggleLight(3)" id="toggleLight4" />
          <span class="title"><label for="toggleLight4">Spot de droite</label></span> <br>
          <span class="label" >Position en Y : </span><input style="float: right; width:50%" type="range" min=minLightHeight.toString() max=maxLightHeight.toString() value=lightPositions[3+1].toString() step="0.1" id="light4Position" onchange="changeLightPos(3, this.value)" oninput="changeLightPos(3, this.value)"/>
        </div>

        <input type="button" value="Inverser l'état de chaque spot" onclick="toggleAllLights()" style="font-size:15px; width: 175px; height: 65px; white-space: normal;" />
        <input type="button" value="Réinitialiser la position de chaque spot" onclick="resetLightsPosition()" style="font-size:15px; width: 175px; height: 65px; white-space: normal;" />
        </br>

      </div>
    </div>
  </body>
</html>
